<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Walker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Better is top!">
<meta property="og:type" content="website">
<meta property="og:title" content="Walker">
<meta property="og:url" content="http://betteris.top/page/2/index.html">
<meta property="og:site_name" content="Walker">
<meta property="og:description" content="Better is top!">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Walker">
<meta name="twitter:description" content="Better is top!">
  
    <link rel="alternate" href="/atom.xml" title="Walker" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Walker</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Better is top!</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://betteris.top"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-RAC-MVVM封装的网络请求" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/RAC-MVVM封装的网络请求/" class="article-date">
  <time datetime="2016-03-22T04:11:29.000Z" itemprop="datePublished">2016-03-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/RAC-MVVM封装的网络请求/">RAC+MVVM封装的网络请求</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-MVVM-代替-MVC-原因"><a href="#1-MVVM-代替-MVC-原因" class="headerlink" title="1.MVVM 代替 MVC 原因"></a>1.MVVM 代替 MVC 原因</h3><p>无论MVC还是MVVM，包括其他设计模式，核心目的是为了提高代码的简洁性，降低耦合度。<br>简单点说就是让专门的人去做专门的事情。<br>比如MVC模式中，</p>
<blockquote>
<ul>
<li>M (model)</li>
<li>V (view)</li>
<li>C (controller)</li>
</ul>
</blockquote>
<p>但在MVC中，通过网络请求回来的数据会放到Model中，作为数据源来调用和处理。<br>但还是存在控制器中文件很大的问题。很多业务逻辑都写到了控制器上了，不利于程序之间的解耦，而且在比较大的项目中，代码的可读性也比较差，而MVVM的引入大大减少了这个问题，会让C释放释放出来，关于视图方面的业务逻辑交给VM处理，C只用来解决控制器之间的连接问题。</p>
<h3 id="2-RAC如何处理和传输数据"><a href="#2-RAC如何处理和传输数据" class="headerlink" title="2.RAC如何处理和传输数据"></a>2.RAC如何处理和传输数据</h3><p>那在RAC中怎么处理和传送数据呢？<br>RAC最核心的内容是信号。我们可以把网络请求回来的数据通过信号传递和发送出去。<br>我们把网络请求回来的数据叫做<code>responseObject</code>。<br>基于RAC(  想深入探究 RAC 原理可点击<a href="http://www.jianshu.com/p/7cf4754cebee" target="_blank" rel="external">史上最全ReactiveCocoa(RAC)之信号类源码解析</a>)的知识，我们让订阅者发送数据，然后让信号接收数据，便完成数据的传递。<br>同时RAC中有<code>RACCommand</code>的类，负责处理事件。<br>所有总体可以分为三步：</p>
<ul>
<li><ol>
<li>网络请求，获得数据<code>responseObject</code>；</li>
</ol>
</li>
<li><ol>
<li>订阅者将<code>responseObject</code>发送出去；</li>
</ol>
</li>
<li><ol>
<li>信号订阅信号（接收发送处理的数据）。</li>
</ol>
</li>
</ul>
<h3 id="3-代码实例"><a href="#3-代码实例" class="headerlink" title="3.代码实例"></a>3.代码实例</h3><p>至于代码层面是怎么解决这三个方面的问题呢?</p>
<p>我们假设一个使用场景：<br>豆瓣上有开放的API，当我们查询图书的时候，当搜索”美女”关键词的时候，会出现很多关于美女的图书。<br>然后将其显示在tableView上。</p>
<p>主要的业务逻辑包括：</p>
<blockquote>
<ul>
<li><ol>
<li>通过AFN请求数据</li>
</ol>
</li>
<li><ol>
<li>将请求回来的数据传递给控制器</li>
</ol>
</li>
<li><ol>
<li>控制器的tableView完成数据的显示</li>
</ol>
</li>
</ul>
</blockquote>
<h4 id="3-1AFN请求数据"><a href="#3-1AFN请求数据" class="headerlink" title="3.1AFN请求数据"></a>3.1AFN请求数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">AFHTTPRequestOperationManager *mgr = [AFHTTPRequestOperationManager manager];</div><div class="line">[mgr GET:@&quot;https://api.douban.com/v2/book/search&quot; parameters:@&#123;@&quot;q&quot;:@&quot;美女&quot;&#125; success:^(AFHTTPRequestOperation * _Nonnull operation, NSDictionary * _Nonnull responseObject) &#123;</div><div class="line">    NSLog(@&quot;发送成功&quot;);</div><div class="line">    NSArray *dictArray = responseObject[@&quot;books&quot;];</div><div class="line">    [subscriber sendNext:dictArray];</div></pre></td></tr></table></figure>
<hr>
<h4 id="3-2请求回来的数据传给控制器"><a href="#3-2请求回来的数据传给控制器" class="headerlink" title="3.2请求回来的数据传给控制器"></a>3.2请求回来的数据传给控制器</h4><p>在MVC中，通常会将请求回来的数据<code>responseObject</code>进行初步的处理，放到<code>model</code>模型中，然后<code>tableView</code>的数据源也来自于model，最终完成<code>tableView</code>的绘制和展示。</p>
<p>这里我们通过MVVM的方式，将网络请求的业务逻辑放到VM中处理。在V中实现<code>tableView</code>的数据源方法。</p>
<p>至于事件的处理就交给RAC来解决。RAC中有一个类<code>RACCommond</code>，来处理事件。</p>
<h4 id="3-3具体代码"><a href="#3-3具体代码" class="headerlink" title="3.3具体代码"></a>3.3具体代码</h4><p>处理的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">//通过RACCommand获取数据</div><div class="line">- (void)getData &#123;</div><div class="line">    self.requestCommand = [[RACCommand alloc]initWithSignalBlock:^RACSignal *(id input) &#123;</div><div class="line">        RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">            </div><div class="line">        AFHTTPRequestOperationManager *mgr = [AFHTTPRequestOperationManager manager];</div><div class="line">        [mgr GET:@&quot;https://api.douban.com/v2/book/search&quot; parameters:@&#123;@&quot;q&quot;:@&quot;美女&quot;&#125; success:^(AFHTTPRequestOperation * _Nonnull operation, NSDictionary * _Nonnull responseObject) &#123;</div><div class="line">            NSLog(@&quot;发送成功&quot;);</div><div class="line">            NSArray *dictArray = responseObject[@&quot;books&quot;];</div><div class="line">            [subscriber sendNext:dictArray];</div><div class="line"></div><div class="line">            &#125; failure:^(AFHTTPRequestOperation * _Nonnull operation, NSError * _Nonnull error) &#123;</div><div class="line">                NSLog(@&quot;发送失败&quot;);</div><div class="line">            &#125;];</div><div class="line">            return nil;</div><div class="line">        &#125;];</div><div class="line">        return signal;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//控制器接受传回来的数据</div><div class="line">- (void)getDataFromRequestVM &#123;</div><div class="line">    RACSignal *signal = [self.requestVM.requestCommand execute:nil];</div><div class="line">    </div><div class="line">    [signal subscribeNext:^(id x) &#123;</div><div class="line">        self.dataArray = x;</div><div class="line">        [self.tableView reloadData];</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-注意："><a href="#4-注意：" class="headerlink" title="4.注意："></a>4.注意：</h3><p>为了避免外部修改，可以使用readOnly<br>以上操作可以分步处理，也可以通过RACCommand的类来处理。</p>
<h3 id="5-github地址"><a href="#5-github地址" class="headerlink" title="5.github地址"></a>5.github地址</h3><p><a href="https://github.com/walkertop/RAC-MVVM-" target="_blank" rel="external">demo下载地址</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://betteris.top/RAC-MVVM封装的网络请求/" data-id="ck76887cr0004lvx9s2i9rsy3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RAC-MVVM/">RAC MVVM</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-RAC之常用方法汇总" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/RAC之常用方法汇总/" class="article-date">
  <time datetime="2016-03-21T04:06:10.000Z" itemprop="datePublished">2016-03-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/RAC之常用方法汇总/">RAC之常用方法汇总</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、iOS内部对不同事件的处理"><a href="#一、iOS内部对不同事件的处理" class="headerlink" title="一、iOS内部对不同事件的处理"></a>一、iOS内部对不同事件的处理</h1><p>iOS中对不同事件作出响应时，会用不同的方式来处理这些业务逻辑。<br>比如按钮的点击使用action，ScrollView滚动使用delegate，属性值改变使用KVO，通知等系统提供的方式。<br>虽然说是对事件做出相应，但iOS内部需要用不同的方法，时常用起来非常的繁琐。其实这些事件，都可以通过RAC处理。</p>
<h1 id="二、RAC的核心介绍"><a href="#二、RAC的核心介绍" class="headerlink" title="二、RAC的核心介绍"></a>二、RAC的核心介绍</h1><p>RAC内部的核心类是<code>RACSiganl</code>。<br>RACSiganl:信号类,一般表示将来有数据传递，只要有数据改变，信号内部接收到数据，就会马上发出数据。</p>
<p><code>ReactiveCocoa</code>为事件提供了很多处理方法，处理起来非常简单，而且代码放在一起，就不需要跳到对应的方法里。非常便于管理，也很符合我们开发中<code>高聚合，低耦合</code>的思想。</p>
<p>在介绍RAC底层时，我们已经对RAC的实现原理做了说明，本文会介绍RAC对不同事件的各种处理方式。</p>
<h1 id="三、简单介绍不同的方法"><a href="#三、简单介绍不同的方法" class="headerlink" title="三、简单介绍不同的方法"></a>三、简单介绍不同的方法</h1><h2 id="ReactiveCocoa开发中常见用法"><a href="#ReactiveCocoa开发中常见用法" class="headerlink" title="ReactiveCocoa开发中常见用法"></a>ReactiveCocoa开发中常见用法</h2><h3 id="3-1-代替代理"><a href="#3-1-代替代理" class="headerlink" title="3.1 代替代理."></a>3.1 代替代理.</h3><p><code>rac_signalForSelector：</code>用于替代代理。</p>
<h3 id="3-2代替KVO"><a href="#3-2代替KVO" class="headerlink" title="3.2代替KVO :"></a>3.2代替KVO :</h3><p><code>rac_valuesAndChangesForKeyPath：</code>用于监听某个对象的属性改变。</p>
<h3 id="3-3-监听事件"><a href="#3-3-监听事件" class="headerlink" title="3.3 监听事件:"></a>3.3 监听事件:</h3><p><code>rac_signalForControlEvents：</code>用于监听某个事件。</p>
<h3 id="3-4-代替通知"><a href="#3-4-代替通知" class="headerlink" title="3.4 代替通知:"></a>3.4 代替通知:</h3><p><code>rac_addObserverForName:</code>用于监听某个通知。</p>
<h3 id="3-5-监听文本框文字改变"><a href="#3-5-监听文本框文字改变" class="headerlink" title="3.5 监听文本框文字改变:"></a>3.5 监听文本框文字改变:</h3><p><code>rac_textSignal:</code>只要文本框发出改变就会发出这个信号。</p>
<h3 id="3-6-处理当界面有多次请求时，需要都获取到数据时，才能展示界面"><a href="#3-6-处理当界面有多次请求时，需要都获取到数据时，才能展示界面" class="headerlink" title="3.6 处理当界面有多次请求时，需要都获取到数据时，才能展示界面"></a>3.6 处理当界面有多次请求时，需要都获取到数据时，才能展示界面</h3><p><code>rac_liftSelector:withSignalsFromArray:Signals:</code>当传入的Signals(信号数组)，每一个signal都至少sendNext过一次，就会去触发第一个selector参数的方法。<br>使用注意：几个信号，参数一的方法就几个参数，每个参数对应信号发出的数据。</p>
<h2 id="四、代码演示"><a href="#四、代码演示" class="headerlink" title="四、代码演示"></a>四、代码演示</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"> // 1.代替代理</div><div class="line">    // 需求：自定义redView,监听红色view中按钮点击</div><div class="line">    // 之前都是需要通过代理监听，给红色View添加一个代理属性，点击按钮的时候，通知代理做事情</div><div class="line">    // rac_signalForSelector:把调用某个对象的方法的信息转换成信号，就要调用这个方法，就会发送信号。</div><div class="line">    // 这里表示只要redV调用btnClick:,就会发出信号，订阅就好了。</div><div class="line">    [[redV rac_signalForSelector:@selector(btnClick:)] subscribeNext:^(id x) &#123;</div><div class="line">        NSLog(@&quot;点击红色按钮&quot;);</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">  // 2.KVO</div><div class="line">    // 把监听redV的center属性改变转换成信号，只要值改变就会发送信号</div><div class="line">    // observer:可以传入nil</div><div class="line">    [[redV rac_valuesAndChangesForKeyPath:@&quot;center&quot; options:NSKeyValueObservingOptionNew observer:nil] subscribeNext:^(id x) &#123;</div><div class="line">        NSLog(@&quot;%@&quot;,x);</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">  // 3.监听事件</div><div class="line">    // 把按钮点击事件转换为信号，点击按钮，就会发送信号</div><div class="line">    [[self.btn rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(id x) &#123;</div><div class="line">       NSLog(@&quot;按钮被点击了&quot;);</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">  // 4.代替通知</div><div class="line">    // 把监听到的通知转换信号</div><div class="line">    [[[NSNotificationCenter defaultCenter] rac_addObserverForName:UIKeyboardWillShowNotification object:nil] subscribeNext:^(id x) &#123;</div><div class="line">        NSLog(@&quot;键盘弹出&quot;);</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">  // 5.监听文本框的文字改变</div><div class="line">   [_textField.rac_textSignal subscribeNext:^(id x) &#123;</div><div class="line">       NSLog(@&quot;文字改变了%@&quot;,x);</div><div class="line">   &#125;];</div><div class="line"></div><div class="line">  // 6.处理多个请求，都返回结果的时候，统一做处理.</div><div class="line">    RACSignal *request1 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">        // 发送请求1</div><div class="line">        [subscriber sendNext:@&quot;发送请求1&quot;];</div><div class="line">        return nil;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    RACSignal *request2 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">        // 发送请求2</div><div class="line">        [subscriber sendNext:@&quot;发送请求2&quot;];</div><div class="line">        return nil;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    // 使用注意：几个信号，参数一的方法就几个参数，每个参数对应信号发出的数据。</div><div class="line">    [self rac_liftSelector:@selector(updateUIWithR1:r2:) withSignalsFromArray:@[request1,request2]];</div><div class="line">&#125;</div><div class="line">// 更新UI（该方法有要求，有多少个信号就要求有多少个参数，参数的内容就是发送的数据。）</div><div class="line">- (void)updateUIWithR1:(id)data r2:(id)data1</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;更新UI%@,%@&quot;,data,data1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="文末："><a href="#文末：" class="headerlink" title="文末："></a>文末：</h1><p>这里只是对RAC常用方法合集的简单描述和基础使用的介绍，至于RAC信号的原理，可以参考作者的<a href="http://betteris.top/2016/03/17/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8ReactiveCocoa-RAC-%E4%B9%8B%E4%BF%A1%E5%8F%B7%E7%B1%BB%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">《史上最全RAC之信号类源码解析》</a>。<br>至于RAC的bind(绑定)，map（映射），concat（组合）等高级用法，可参考作者的其它文章。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://betteris.top/RAC之常用方法汇总/" data-id="ck76887cv0007lvx94dbapyfd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RAC/">RAC</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-RAC之masonry源码深度解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/RAC之masonry源码深度解析/" class="article-date">
  <time datetime="2016-03-19T03:52:58.000Z" itemprop="datePublished">2016-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/RAC之masonry源码深度解析/">RAC之masonry源码深度解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>写在前面：<br>本文不是讲解masonry的基础使用，而是希望借着masonry的源码解析给大家渗透链式编程的思想和展示其具体实现。<br>现在RAC（ReactiveCocoa）很火，借着这个成熟的案例让大家窥其一斑，作者在此抛砖引用，供大家交流参考。</p>
<h1 id="一、NSLayoutConstraint约束"><a href="#一、NSLayoutConstraint约束" class="headerlink" title="一、NSLayoutConstraint约束"></a><strong>一、NSLayoutConstraint约束</strong></h1><p>实际iOS用<code>NSLayoutConstraint</code>对控件进行约束。比如：想要让子控件的顶部距离父控件顶部10pt，添加约束的实际条件就是满足<code>subView.top = superView.top * 1 + 10</code>这个公式就可以了。<br><code>NSLayoutConstraint</code>的实际就是对该公式的代码解释，代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">    NSLayoutConstraint *topConstraint = [NSLayoutConstraint constraintWithItem:subView</div><div class="line">                                 attribute:NSLayoutAttributeTop</div><div class="line">                                 relatedBy:NSLayoutRelationEqual</div><div class="line">                                    toItem:self.view</div><div class="line">                                 attribute:NSLayoutAttributeTop</div><div class="line">                                multiplier:1.0</div><div class="line">                                                                   constant:padding.top];</div><div class="line">    [self.view addConstraints:topConstraint];</div></pre></td></tr></table></figure>
<p>但我们需要对控件的top,bottom,left,right进行约束就特别麻烦。在OC中有一个库<code>Masonry</code>对<code>NSLayoutConstraint</code>进行了封装，<strong><em>**</em></strong>（<strong><strong>Swift</strong></strong>中使用<strong><strong>SnapKit</strong></strong>，<strong><strong>SnapKit</strong></strong>其实就是<strong><strong>Masonry</strong></strong>的<strong><strong>Swift</strong></strong>版本，实现思路大体一致。）<strong><em>**</em></strong></p>
<h1 id="二：masonry介绍"><a href="#二：masonry介绍" class="headerlink" title="二：masonry介绍"></a>二：masonry介绍</h1><p>masonry是iOS布局控件的轻量级框架。其原理是通过链式调用的方式对<code>NSLayoutConstraint</code>进行封装，简化了控件的约束方式。</p>
<p>抓住两头：<br>其实massory最终还是利用苹果官方提供的<code>NSLayoutConstraint</code>，只是利用链式编程的方式进一步封装。</p>
<blockquote>
<p>接下来思考两个问题</p>
<ol>
<li>怎么通过封装？</li>
<li>链式编程来实现约束的添加的？</li>
</ol>
</blockquote>
<p>接下来我们就对masonry的封装做进一步解释。</p>
<h2 id="1-masonry添加约束的代码实现"><a href="#1-masonry添加约束的代码实现" class="headerlink" title="1.masonry添加约束的代码实现"></a>1.masonry添加约束的代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    UIView *subView = [[UIView alloc]init];</div><div class="line">    subView.backgroundColor = [UIColor purpleColor];</div><div class="line">    </div><div class="line">    //先添加控制，后设置约束，不然找不到约束的依赖，会报错。</div><div class="line">    [self.view addSubview:subView];</div><div class="line">    [subView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.left.top.equalTo(@20);</div><div class="line">        make.right.bottom.equalTo(@-10);</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2-masonry方法执行步骤解析："><a href="#2-masonry方法执行步骤解析：" class="headerlink" title="2.masonry方法执行步骤解析："></a>2.masonry方法执行步骤解析：</h2><blockquote>
<ul>
<li>子控件调用<code>mas_makeConstraints</code>方法，<code>mas_makeConstraints</code>方法有个block参数（返回值为void,参数为<code>MASContraintMaker</code>的实例对象make）；</li>
<li>block作为方法的参数就是隐式调用（block并没有真正调用，需要在方法内部，block()调用一次，才会真正执行block）；</li>
<li>block的有一个MASContraintMaker类的实例make作为参数，让make去添加约束；</li>
<li>MASContraintMaker类中有个可变数组的属性，用于保存约束；</li>
<li>执行<code>mas_makeConstraints</code>传入进行的block；</li>
<li>遍历数组中的约束，完成约束的安装；</li>
</ul>
</blockquote>
<hr>
<p>以上只是文字描述了执行的大致步骤，具体的代码实现是怎么样的呢？<br>我们接下里通过三个问题来展开。</p>
<h2 id="3-疑问"><a href="#3-疑问" class="headerlink" title="3.疑问"></a>3.疑问</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; 1. make的点语法代表什么意思？</div><div class="line">&gt; 2. 为什么可以连续用点语法？</div><div class="line">&gt; 3. 具体代码解析是什么样的？</div></pre></td></tr></table></figure>
<hr>
<h3 id="问题一：make的点语法代表什么意思？"><a href="#问题一：make的点语法代表什么意思？" class="headerlink" title="问题一：make的点语法代表什么意思？"></a>问题一：make的点语法代表什么意思？</h3><p><code>make.left.top.equalTo(@20);</code></p>
<p>实质就是<code>MASContraintMaker</code>类的实例对象make调用了属性的getterter方法。<br>扒开源码我们会看到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@interface MASConstraintMaker : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, strong, readonly) MASConstraint *left;</div><div class="line">@property (nonatomic, strong, readonly) MASConstraint *top;</div><div class="line">//省略了bottom,right，baseline等属性。</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">//getter方法，返回的是MASConstraint对象，getter方法调用 addConstraintWithLayoutAttribute:</div><div class="line">- (MASConstraint *)left &#123;</div><div class="line">    return [self addConstraintWithLayoutAttribute:NSLayoutAttributeLeft];</div><div class="line">&#125;</div><div class="line"></div><div class="line">//返回的是MASConstraint对象，接着调用constraint: addConstraintWithLayoutAttribute:方法</div><div class="line">- (MASConstraint *)addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute &#123;</div><div class="line">    return [self constraint:nil addConstraintWithLayoutAttribute:layoutAttribute];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (MASConstraint *)constraint:(MASConstraint *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute &#123;</div><div class="line">    MASViewAttribute *viewAttribute = [[MASViewAttribute alloc] initWithView:self.view layoutAttribute:layoutAttribute];</div><div class="line">    MASViewConstraint *newConstraint = [[MASViewConstraint alloc] initWithFirstViewAttribute:viewAttribute];</div><div class="line">    if ([constraint isKindOfClass:MASViewConstraint.class]) &#123;</div><div class="line">        //replace with composite constraint</div><div class="line">        NSArray *children = @[constraint, newConstraint];</div><div class="line">        MASCompositeConstraint *compositeConstraint = [[MASCompositeConstraint alloc] initWithChildren:children];</div><div class="line">        compositeConstraint.delegate = self;</div><div class="line">        [self constraint:constraint shouldBeReplacedWithConstraint:compositeConstraint];</div><div class="line">        return compositeConstraint;</div><div class="line">    &#125;</div><div class="line">    if (!constraint) &#123;</div><div class="line">        newConstraint.delegate = self;</div><div class="line">        </div><div class="line">        //</div><div class="line">        [self.constraints addObject:newConstraint];</div><div class="line">    &#125;</div><div class="line">    return newConstraint;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="问题二：为什么可以连续用点语法？"><a href="#问题二：为什么可以连续用点语法？" class="headerlink" title="问题二：为什么可以连续用点语法？"></a>问题二：为什么可以连续用点语法？</h3><blockquote>
<p><strong>链式编程的核心：</strong><br>每个点语法实际调用的getter方法，getter方法的返回值为实例对象本身，然后继续调用getter方法，就成为链式了。<br>结合代码进行具体解释：<code>make.left.top.equalTo(@10);</code><br>我们对其分开解释：点语法返回的时一个新的约束newConstraint。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">`make.left.top.equalTo(@10);`</div><div class="line">//分开写就为</div><div class="line">newConstraint1 = make.left;</div><div class="line">newConstraint2 = newConstraint1.top;</div><div class="line">newConstraint2.equalTo(@10);</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (MASConstraint * (^)(id))equalTo &#123;</div><div class="line">    return ^id(id attribute) &#123;</div><div class="line">        return self.equalToWithRelation(attribute, NSLayoutRelationEqual);</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="问题三：整个方法的具体调用步骤是什么样的？"><a href="#问题三：整个方法的具体调用步骤是什么样的？" class="headerlink" title="问题三：整个方法的具体调用步骤是什么样的？"></a>问题三：整个方法的具体调用步骤是什么样的？</h3><p>首先解释下<code>MASConstraintMaker</code>类：</p>
<blockquote>
<p><code>MASConstraintMaker</code>类就是一个工厂类，负责创建<code>MASConstraint</code>类型的对象（依赖于<code>MASConstraint</code>接口，而不依赖于具体实现）</p>
</blockquote>
<hr>
<blockquote>
<p><strong>粗略步骤：</strong></p>
<ol>
<li>UIView的类调用<code>mas_makeConstraints</code>方法</li>
<li><code>mas_makeConstraints</code>有个block参数，会做隐式回调</li>
<li>获得约束数组，通过install安装约束。</li>
</ol>
</blockquote>
<h4 id="1-mas-makeConstraints方法解析"><a href="#1-mas-makeConstraints方法解析" class="headerlink" title="1.mas_makeConstraints方法解析"></a>1.<code>mas_makeConstraints</code>方法解析</h4><p>用户是UIView调用扩展的<code>UIView+MASAdditions</code>分类的<code>mas_makeConstraints</code>方法来为当前视图添加约束的。<br>mas_makeConstraints方法的返回值是一个数组（NSArray）,数组中所存放的就是当前视图中所添加的所有约束。因为Masonry框架对NSLayoutConstraint封装成了MASViewConstraint，所有此处数组中存储的是MASViewConstraint对象。</p>
<p>接下来来看<code>mas_makeConstraints</code>的参数，<code>mas_makeConstraints</code>测参数是一个类型为<code>void(^)(MASConstraintMaker *)</code>的匿名block（也就是匿名闭包），该闭包的返回值为void, 并且需要一个<code>MASConstraintMaker</code>工厂类的一个对象。该闭包的作用就是可以让<code>mas_makeConstraints</code>方法通过该block给<code>MASConstraintMaker</code>工厂类对象中的<code>MAConstraint</code>属性进行初始化。<br>具体可以参考下面的代码及其注释:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//新建并添加约束</div><div class="line">- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *))block &#123;</div><div class="line">   //关闭自动添加约束，由我们手动添加约束</div><div class="line">    self.translatesAutoresizingMaskIntoConstraints = NO;</div><div class="line">    //实例化constraintMaker对象，来操作接下来的约束</div><div class="line">    MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:self];</div><div class="line">    //block作为参数，这里完成隐式调用，完成回调，通过block将constraintMaker对象回调给用户让用户对constraintMaker中的MAConstraint类型的属性进行初始化。换句话说block中所做的事情就是之前用户设置约束是所添加的代码，比如make.top(@10) == ( constraintMaker.top = 10 )。</div><div class="line">    block(constraintMaker);</div><div class="line">    //添加约束，但会Install的约束数组</div><div class="line">    return [constraintMaker install];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-block参数的隐式回调"><a href="#2-block参数的隐式回调" class="headerlink" title="2. block参数的隐式回调"></a>2. block参数的隐式回调</h4><p>返回的值为一个block,block的返回值是MASConstraint类的实例对象，所以最终还是返回的MASConstraint类的实例对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (MASConstraint * (^)(id))equalTo &#123;</div><div class="line">    return ^id(id attribute) &#123;</div><div class="line">        return self.equalToWithRelation(attribute, NSLayoutRelationEqual);</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="3-约束安装install方法"><a href="#3-约束安装install方法" class="headerlink" title="3.约束安装install方法"></a>3.约束安装install方法</h4><p>实际的过程是：</p>
<blockquote>
<ol>
<li>判断是否有约束，有就遍历约束，调用uninstall清空之前所有的约束</li>
<li>无约束，就遍历数组的约束对象，然后调用install逐个安装</li>
<li>调用系统的方法安装约束</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (NSArray *)install &#123;</div><div class="line">  //判断是否存在约束，存在就遍历所有约束，然后移除</div><div class="line">    if (self.removeExisting) &#123;</div><div class="line">        NSArray *installedConstraints = [MASViewConstraint installedConstraintsForView:self.view];</div><div class="line">        for (MASConstraint *constraint in installedConstraints) &#123;</div><div class="line">            [constraint uninstall];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">     //不存在约束，就复制约束，然后遍历数组中的约束，完成安装。</div><div class="line">    NSArray *constraints = self.constraints.copy;</div><div class="line">    for (MASConstraint *constraint in constraints) &#123;</div><div class="line">        constraint.updateExisting = self.updateExisting;</div><div class="line">        [constraint install];</div><div class="line">    &#125;</div><div class="line">    [self.constraints removeAllObjects];</div><div class="line">    return constraints;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="文末："><a href="#文末：" class="headerlink" title="文末："></a>文末：</h2><p>以上是masonry。通过这个也是给大家渗透链式编程的思想。<br>可能很多人对block作为返回值比较难理解，但这是整个链式编程的核心。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://betteris.top/RAC之masonry源码深度解析/" data-id="ck76887cu0006lvx91p6j60jt" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-史上最全ReactiveCocoa-RAC-之信号类源码解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/史上最全ReactiveCocoa-RAC-之信号类源码解析/" class="article-date">
  <time datetime="2016-03-17T04:01:13.000Z" itemprop="datePublished">2016-03-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/史上最全ReactiveCocoa-RAC-之信号类源码解析/">史上最全ReactiveCocoa(RAC)之信号类源码解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>信号signal是RAC的绝对核心，所有的操作都是围绕着信号来处理的。<br>比如：创建信号，订阅信号，发送信号是消息发送的核心步骤。<br>常见的三个信号类为：</p>
<blockquote>
<ul>
<li>RACSignal</li>
<li>RACSubject</li>
<li>RACReplaySubject</li>
</ul>
</blockquote>
<h1 id="一、RACSignal"><a href="#一、RACSignal" class="headerlink" title="一、RACSignal"></a>一、RACSignal</h1><h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 1.创建信号</div><div class="line">    RACSignal *siganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">       // 注：block在此仅仅是个参数，未被调用，</div><div class="line">       //当有订阅者订阅信号时会调用block。</div><div class="line">// 2.发送信号</div><div class="line">        [subscriber sendNext:@1];</div><div class="line">        // 如果不在发送数据，最好发送信号完成，内部会自动调用[RACDisposable disposable]取消订阅信号。</div><div class="line">        return nil;</div><div class="line">    &#125;];</div><div class="line">// 3.订阅信号,才会激活信号.</div><div class="line">    [siganl subscribeNext:^(id x) &#123;</div><div class="line">        // block调用时刻：每当有信号发出数据，就会调用block.</div><div class="line">        NSLog(@&quot;接收到数据:%@&quot;,x);</div><div class="line">    &#125;];</div></pre></td></tr></table></figure>
<hr>
<h2 id="使用步骤："><a href="#使用步骤：" class="headerlink" title="使用步骤："></a>使用步骤：</h2><h3 id="1-创建信号"><a href="#1-创建信号" class="headerlink" title="1.创建信号"></a>1.创建信号</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+(RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">内部原理：</div><div class="line">* 1.1 方法解析：方法名为createSignal：其返回值类型为RACSignal类的实例变量。参数为一个名字为didSubscribe的block。</div><div class="line">* 1.2 方法参数didSubscribe解析：(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe &#123;&#125;的返回值是RACDisposable类型的实例变量，参数为id类型且遵守且遵守RACSubscriber协议的subscriber。</div><div class="line">* 1.3 创建信号，首先把didSubscribe这个block保存到信号中，但不会触发。此时didSubscribe仅仅作为方法的参数，并没有被触发，所以信号也仅仅是一个冷信号，block内部不会执行。（具体执行见下文）</div><div class="line"></div><div class="line">源码解析：</div><div class="line">+ (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe &#123;</div><div class="line">//创建了一个RACDynamicSignal类的信号</div><div class="line">RACDynamicSignal *signal = [[self alloc] init];</div><div class="line">//将代码块保存到信号里面（但此时仅仅是保存，没有调用）</div><div class="line">signal-&gt;_didSubscribe = [didSubscribe copy];</div><div class="line">return [signal setNameWithFormat:@&quot;+createSignal:&quot;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="2-订阅信号"><a href="#2-订阅信号" class="headerlink" title="2.订阅信号"></a>2.订阅信号</h3><blockquote>
<p>（激活信号，冷信号编程热信号）</p>
<ul>
<li>(RACDisposable *)subscribeNext:(void (^ )(id x))nextBlock；</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">* 2.1当信号被订阅，也就是调用signal的subscribeNext:nextBlock，</div><div class="line">* 2.2nextBlock内部创建了订阅者subscriber，并且把nextBlock保存到subscriber中。</div><div class="line">//  RACSignal.h</div><div class="line">- (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock &#123;</div><div class="line">NSCParameterAssert(nextBlock != NULL);</div><div class="line"> //内部创建了RACSubscriber（订阅者）类的实例对象o，并且将nextBlock保存到o中，在返回值出执行o,实际也是执行了nextBlock。</div><div class="line">RACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:NULL completed:NULL];</div><div class="line">return [self subscribe:o]; //内部执行了nextBlock，具体见下文</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (instancetype)subscriberWithNext:(void (^)(id x))next error:(void (^)(NSError *error))error completed:(void (^)(void))completed &#123;</div><div class="line"> RACSubscriber *subscriber = [[self alloc] init];</div><div class="line">//将block保存到subscriber中</div><div class="line"> subscriber-&gt;_next = [next copy];</div><div class="line"> subscriber-&gt;_error = [error copy];</div><div class="line"> subscriber-&gt;_completed = [completed copy];</div><div class="line"></div><div class="line"> return subscriber;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//执行</div><div class="line">- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber &#123;</div><div class="line"> NSCParameterAssert(subscriber != nil);</div><div class="line"></div><div class="line"> RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];</div><div class="line"> subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:self disposable:disposable];</div><div class="line">//判断有无self.didSubscribe,有则执行该self.didSubscribe，意味着将订阅者subscriber发送过去</div><div class="line"> if (self.didSubscribe != NULL) &#123;</div><div class="line">  RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^&#123;</div><div class="line">   RACDisposable *innerDisposable = self.didSubscribe(subscriber);</div><div class="line">   [disposable addDisposable:innerDisposable];</div><div class="line">  &#125;];</div><div class="line"></div><div class="line">  [disposable addDisposable:schedulingDisposable];</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> return disposable;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="3-发送信号"><a href="#3-发送信号" class="headerlink" title="3.发送信号"></a>3.发送信号</h3><blockquote>
<p>订阅信号时，将subscriber传递给didSubscribe的参数subscriber</p>
<p>利用[subscriber sendNext:@1]方法发送信号。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//  RACSubscriber.h</div><div class="line">// These callbacks should only be accessed while synchronized on self.</div><div class="line">@property (nonatomic, copy) void (^next)(id value);</div><div class="line"></div><div class="line">//名为next的block是返回值为void，参数为id类型的value，在sendNext:内部，将next复制给nextBlock，执行该方法后，subscribeNext:的block参数才会被调用。</div><div class="line"></div><div class="line">- (void)sendNext:(id)value &#123;</div><div class="line"> @synchronized (self) &#123;</div><div class="line">  void (^nextBlock)(id) = [self.next copy];</div><div class="line">  if (nextBlock == nil) return;</div><div class="line">  //执行nextBlock，发送value</div><div class="line">  nextBlock(value);</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="RACSignal原理流程图："><a href="#RACSignal原理流程图：" class="headerlink" title="RACSignal原理流程图："></a>RACSignal原理流程图：</h2><p><img src="http://upload-images.jianshu.io/upload_images/1467716-d6ea285e8b921f99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RACSignal实现原理图.png"></p>
<hr>
<h2 id="RACSignal总结："><a href="#RACSignal总结：" class="headerlink" title="RACSignal总结："></a>RACSignal总结：</h2><p>三步骤（先创建信号，然后订阅信号，最后执行didSubscribe内部的方法）顺序是不能变的。<br>&gt;</p>
<blockquote>
<p>RACSignal底层实现：</p>
<pre><code>* 1.创建信号，首先把didSubscribe保存到信号中，还不会触发。
* 2.当信号被订阅，也就是调用signal的subscribeNext:nextBlock
  2.1 subscribeNext内部会创建订阅者subscriber，并且把nextBlock保存到subscriber中。
   2.2 subscribeNext内部会调用siganl的didSubscribe
* 3.siganl的didSubscribe中调用[subscriber sendNext:@1];
* 3.1 sendNext底层其实就是执行subscriber的nextBlock
</code></pre></blockquote>
<hr>
<h1 id="二、RACSubject"><a href="#二、RACSubject" class="headerlink" title="二、RACSubject"></a>二、RACSubject</h1><blockquote>
<p>RACSubject:信号提供者，自己可以充当信号，又能发送信号。</p>
</blockquote>
<p>先来简单回顾下，RACSignal类中发送和订阅信号是两步完成的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//发送信号的为遵守RACSubscribe协议的对象subscriber完成发送</div><div class="line">[subscriber sendNext:@1];</div><div class="line">//订阅信号的为RACSignal的实例对象</div><div class="line">[siganl subscribeNext:^(id x) &#123;&#125;；</div></pre></td></tr></table></figure>
<ul>
<li>疑问：有没有办法让一个对象既能发送也可以发送消息呢？</li>
</ul>
<p>其实很简单，只要让具有RACSignal对象遵守RACSubscribe协议，就既能发送，又能订阅信号了。<br>这个类就是RACSubject。虽然和RACSignal一样都具有订阅和发送信号的能力，但其内部原理不同。<br>下文是对RACSubject类进行剖析。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><blockquote>
<p>调用顺序不变，但是可以创建多个订阅者，并发送信号；</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"> // 1.创建信号</div><div class="line">    RACSubject *subject = [RACSubject subject];   </div><div class="line">// 2.订阅信号（这里可以创建多个订阅者）</div><div class="line">    [subject subscribeNext:^(id x) &#123;</div><div class="line">        // block调用时刻：当信号发出新值，就会调用.</div><div class="line">        NSLog(@&quot;第一个订阅者%@&quot;,x);</div><div class="line">    &#125;];</div><div class="line">    [subject subscribeNext:^(id x) &#123;</div><div class="line">        // block调用时刻：当信号发出新值，就会调用.</div><div class="line">        NSLog(@&quot;第二个订阅者%@&quot;,x);</div><div class="line">    &#125;];</div><div class="line">     [subject subscribeNext:^(id x) &#123;</div><div class="line">        // block调用时刻：当信号发出新值，就会调用.</div><div class="line">        NSLog(@&quot;第三个订阅者%@&quot;,x);</div><div class="line">    &#125;];</div><div class="line">// 3.发送信号</div><div class="line">    [subject sendNext:@&quot;1&quot;];</div></pre></td></tr></table></figure>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="1-创建信号-1"><a href="#1-创建信号-1" class="headerlink" title="1.创建信号"></a>1.创建信号</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//  RACSubject.m</div><div class="line">+ (instancetype)subject &#123;</div><div class="line"> return [[self alloc] init];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)init &#123;</div><div class="line"> self = [super init];</div><div class="line"> if (self == nil) return nil;</div><div class="line"> </div><div class="line"> _disposable = [RACCompoundDisposable compoundDisposable];</div><div class="line"> </div><div class="line"> _subscribers = [[NSMutableArray alloc] initWithCapacity:1];</div><div class="line"> </div><div class="line"> return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-订阅信号-1"><a href="#2-订阅信号-1" class="headerlink" title="2.订阅信号"></a>2.订阅信号</h3><blockquote>
<p>不同类型的信号，创建订阅者的方式不同，RACSignal订阅信号时，调用了形影的block。</p>
<p>而RACSubject订阅信号的实质就是将内部创建的订阅者保存在订阅者数组self.subscribers中，仅此而已。订阅者对象有一个名为nextBlock的block参数。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">- (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock &#123;</div><div class="line"> NSCParameterAssert(nextBlock != NULL);</div><div class="line"> </div><div class="line"> RACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:NULL completed:NULL];</div><div class="line"> return [self subscribe:o];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber &#123;</div><div class="line"> NSCParameterAssert(subscriber != nil);</div><div class="line"></div><div class="line"> RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];</div><div class="line"> subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:self disposable:disposable];</div><div class="line"></div><div class="line"> NSMutableArray *subscribers = self.subscribers;</div><div class="line"> @synchronized (subscribers) &#123;</div><div class="line"> //将订阅者保存在订阅者数组中</div><div class="line">  [subscribers addObject:subscriber];</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> return [RACDisposable disposableWithBlock:^&#123;</div><div class="line">  @synchronized (subscribers) &#123;</div><div class="line">   // Since newer subscribers are generally shorter-lived, search</div><div class="line">   // starting from the end of the list.</div><div class="line">   NSUInteger index = [subscribers indexOfObjectWithOptions:NSEnumerationReverse passingTest:^ BOOL (id&lt;RACSubscriber&gt; obj, NSUInteger index, BOOL *stop) &#123;</div><div class="line">    return obj == subscriber;</div><div class="line">   &#125;];</div><div class="line"></div><div class="line">   if (index != NSNotFound) [subscribers removeObjectAtIndex:index];</div><div class="line">  &#125;</div><div class="line"> &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-发送信号-1"><a href="#3-发送信号-1" class="headerlink" title="3.发送信号"></a>3.发送信号</h3><blockquote>
<p>底层实现是：</p>
<ol>
<li>先遍历订阅者数组中的订阅者;</li>
<li>后执行订阅者中的nextBlock;</li>
<li>最后让订阅者发送信号。</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">//  RACSubject.m</div><div class="line"></div><div class="line">- (void)sendNext:(id)value &#123;</div><div class="line">//顺序A：遍历保存在数组中的订阅者对象</div><div class="line"> [self enumerateSubscribersUsingBlock:^(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">//顺序E：调用订阅者，执行sendNext:方法</div><div class="line">  [subscriber sendNext:value];</div><div class="line"> &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">//顺序B:遍历subscribers数组中的订阅者对象，执行block。</div><div class="line">- (void)enumerateSubscribersUsingBlock:(void (^)(id&lt;RACSubscriber&gt; subscriber))block &#123;</div><div class="line"> NSArray *subscribers;</div><div class="line"> @synchronized (self.subscribers) &#123;</div><div class="line">  subscribers = [self.subscribers copy];</div><div class="line"> &#125;</div><div class="line">//顺序C:遍历数组，取出subscriber的block，并且执行。</div><div class="line"> for (id&lt;RACSubscriber&gt; subscriber in subscribers) &#123;</div><div class="line">//顺序D,执行block</div><div class="line">  block(subscriber);</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="RACSubject原理流程图："><a href="#RACSubject原理流程图：" class="headerlink" title="RACSubject原理流程图："></a>RACSubject原理流程图：</h2><p><img src="http://upload-images.jianshu.io/upload_images/1467716-f2b4f5f91210d0ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RACSubject原理图 .png"></p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">RACSubscriber:表示订阅者的意思，用于发送信号，这是一个协议，不是一个类，只要遵守这个协议，并且实现方法才能成为订阅者。通过create创建的信号，都有一个订阅者，帮助他发送数据。</div><div class="line"></div><div class="line">RACDisposable:用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。</div></pre></td></tr></table></figure>
<blockquote>
<p>RACSubject:底层实现和RACSignal不一样。</p>
</blockquote>
<ul>
<li><p>1.调用subscribeNext订阅信号，只是把订阅者保存起来，并且订阅者的nextBlock已经赋值了。</p>
</li>
<li><p>2.调用sendNext发送信号，遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。</p>
</li>
<li>3.由于本质是将订阅者保存到数组中，所以可以有多个订阅者订阅信息。</li>
</ul>
<p>使用场景:不想监听某个信号时，可以通过它主动取消订阅信号。<br>RACSubject:信号提供者，自己可以充当信号，又能发送信号。</p>
<p>使用场景:通常用来代替代理，有了它，就不必要定义代理了。</p>
<blockquote>
<p><strong>缺点：</strong><br>还是必须先订阅，后发送信息。订阅信号就是创建订阅者的过程，如果不先订阅，数组中就没有订阅者对象，那就通过订阅者发送消息。</p>
</blockquote>
<hr>
<h1 id="三、RACReplaySubject"><a href="#三、RACReplaySubject" class="headerlink" title="三、RACReplaySubject"></a>三、RACReplaySubject</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>上文中提到了，RACSubject要求先订阅，后发送信号。<br><strong>##**</strong>代码实现：**</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 1.创建信号</div><div class="line">    RACReplaySubject *subject = [RACReplaySubject subject];</div><div class="line">// 2.订阅信号</div><div class="line">    [subject subscribeNext:^(id x) &#123;</div><div class="line">        NSLog(@&quot;%@&quot;,x);</div><div class="line">    &#125;];</div><div class="line">    // 遍历所有的值,拿到当前订阅者去发送数据</div><div class="line">// 3.发送信号</div><div class="line">    [subject sendNext:@1];</div><div class="line">    // RACReplaySubject发送数据:</div><div class="line">    // 1.保存值</div><div class="line">    // 2.遍历所有的订阅者,发送数据</div><div class="line">    </div><div class="line">    // RACReplaySubject:可以先发送信号,在订阅信号</div></pre></td></tr></table></figure>
<h2 id="使用步骤：-1"><a href="#使用步骤：-1" class="headerlink" title="使用步骤："></a>使用步骤：</h2><h3 id="1-创建信号-2"><a href="#1-创建信号-2" class="headerlink" title="1.创建信号"></a>1.创建信号</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//  RACReplaySubject.m</div><div class="line"></div><div class="line">+ (instancetype)subject &#123;</div><div class="line"> return [[self alloc] init];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (instancetype)init &#123;</div><div class="line"> return [self initWithCapacity:RACReplaySubjectUnlimitedCapacity];</div><div class="line">&#125;</div><div class="line">//此时调用的子类RACReplaySubject的初始化方法</div><div class="line">- (instancetype)initWithCapacity:(NSUInteger)capacity &#123;</div><div class="line"> self = [super init];</div><div class="line"> if (self == nil) return nil;</div><div class="line"> </div><div class="line"> _capacity = capacity;</div><div class="line">//会用_valuesReceived这个数组保存值value</div><div class="line"> _valuesReceived = (capacity == RACReplaySubjectUnlimitedCapacity ? [NSMutableArray array] : [NSMutableArray arrayWithCapacity:capacity]);</div><div class="line"> </div><div class="line"> return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-订阅信号-2"><a href="#2-订阅信号-2" class="headerlink" title="2.订阅信号"></a>2.订阅信号</h3><blockquote>
<p>遍历拿到保存在数组中的所有值，然后调用subscriber发送信号。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">- (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock &#123;</div><div class="line"> NSCParameterAssert(nextBlock != NULL);</div><div class="line"> </div><div class="line"> RACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:NULL completed:NULL];</div><div class="line"> return [self subscribe:o];      //创建订阅者的方式不同</div><div class="line">&#125;</div><div class="line"></div><div class="line">//RACReplaySubject类对象执行[self subscribe:o]</div><div class="line">- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber &#123;</div><div class="line"> RACCompoundDisposable *compoundDisposable = [RACCompoundDisposable compoundDisposable];</div><div class="line"></div><div class="line"> RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^&#123;</div><div class="line">  @synchronized (self) &#123;</div><div class="line">//先遍历self.valuesReceived的所有的值，后让subscriber调用sendNext:发送信号。</div><div class="line">   for (id value in self.valuesReceived) &#123;</div><div class="line">    if (compoundDisposable.disposed) return;</div><div class="line"></div><div class="line">    [subscriber sendNext:(value == RACTupleNil.tupleNil ? nil : value)];</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   if (compoundDisposable.disposed) return;</div><div class="line"></div><div class="line">   if (self.hasCompleted) &#123;</div><div class="line">    [subscriber sendCompleted];</div><div class="line">   &#125; else if (self.hasError) &#123;</div><div class="line">    [subscriber sendError:self.error];</div><div class="line">   &#125; else &#123;</div><div class="line">    RACDisposable *subscriptionDisposable = [super subscribe:subscriber];</div><div class="line">    [compoundDisposable addDisposable:subscriptionDisposable];</div><div class="line">   &#125;</div><div class="line">  &#125;</div><div class="line"> &#125;];</div><div class="line"></div><div class="line"> [compoundDisposable addDisposable:schedulingDisposable];</div><div class="line"></div><div class="line"> return compoundDisposable;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-发送信号-2"><a href="#3-发送信号-2" class="headerlink" title="3.发送信号"></a>3.发送信号</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (void)sendNext:(id)value &#123;</div><div class="line"> @synchronized (self) &#123;</div><div class="line">//重点：发送信号的时候，会先将值value保存到数组中，</div><div class="line">  [self.valuesReceived addObject:value ?: RACTupleNil.tupleNil];</div><div class="line">//调用父类发送（先遍历订阅者，然后发送值value）</div><div class="line">  [super sendNext:value];</div><div class="line">  </div><div class="line">  if (self.capacity != RACReplaySubjectUnlimitedCapacity &amp;&amp; self.valuesReceived.count &gt; self.capacity) &#123;</div><div class="line">   [self.valuesReceived removeObjectsInRange:NSMakeRange(0, self.valuesReceived.count - self.capacity)];</div><div class="line">  &#125;</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="RACReplaySubject原理图"><a href="#RACReplaySubject原理图" class="headerlink" title="RACReplaySubject原理图"></a>RACReplaySubject原理图</h2><p><img src="http://upload-images.jianshu.io/upload_images/1467716-df43b214a0a047c4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RACReplaySubject原理图.jpg"></p>
<h2 id="RACReplaySubject总结"><a href="#RACReplaySubject总结" class="headerlink" title="RACReplaySubject总结"></a>RACReplaySubject总结</h2><p>RACReplaySubject是RACSubject的子类。</p>
<p>RACReplaySubject使用步骤:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// 1.创建信号 [RACSubject subject]，跟RACSiganl不一样，创建信号时没有block。</div><div class="line">// 2.可以先订阅信号，也可以先发送信号。</div><div class="line">  // 2.1 订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock</div><div class="line">  // 2.2 发送信号 sendNe</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://betteris.top/史上最全ReactiveCocoa-RAC-之信号类源码解析/" data-id="ck76887d4000klvx9mdz5huh2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RAC/">RAC</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-趣谈iOS运行时之方法调用原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/趣谈iOS运行时之方法调用原理/" class="article-date">
  <time datetime="2016-01-19T04:13:53.000Z" itemprop="datePublished">2016-01-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/趣谈iOS运行时之方法调用原理/">趣谈iOS运行时之方法调用原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><p>一个成熟的计算机语言必然有丰富的体系，复杂的容错机制，处理逻辑以及判断逻辑。但这些复杂的逻辑都是围绕一个主线丰富和展开的，所以在学习计算机语言的时候，先掌握核心，然后了解其原理，明白程序语言设计的实质和当时选择这种处理方式的原因是极其必要的，而且也是学习语言的捷径。</p>
<p><strong>所以在学习的过程中，需要把握几个核心</strong></p>
<blockquote>
<p>先专注主线，后丰富周边；<br>先宏观了解，后微观精通;<br>多设身处地思考，理解代码设计的原因;<br>理解代码设计的原理和优化</p>
</blockquote>
<hr>
<p>OC中处理方法的业务逻辑和其他语言不同，OC语言是动态语言（<code>动态绑定</code>，<code>动态加载</code>(dynamatic binding),<code>动态类型</code>）。其中动态加载就涉及到OC的运行时。在OC中，方法是动态实现的，调用方法实际就是在<code>发送消息</code>。<br><strong>试想一下，一个方法的实现必然包含三个部分：</strong></p>
<blockquote>
<p>1.执行方法的对象<br>2.方法名称<br>3.不确定的参数</p>
</blockquote>
<p><code>SEL</code>只是一个方法名称，<code>IMP</code>才是执行方法最终的函数。<code>IMP</code> 是一个函数指针,包含一个<code>接收消息的对象</code> id(self 指针), <code>调用方法的选标</code> <code>SEL</code> (方法名),以及不定个数的<code>参数</code>,并返回一个 id。也就是说 <code>IMP</code> 是消息最终调用的执行代码,是方法真正的实现代码 。</p>
<hr>
<p>提问时间到了：</p>
<blockquote>
<ul>
<li>动态和静态有什么区别？</li>
<li>执行方法是怎么实现的？</li>
<li>OC的方法和C语言的函数原理一样么？</li>
</ul>
</blockquote>
<p>动态和静态有区别的；首先我们从最表层理解，一个方法的实现必然要包含执行者，方法名和不确定的参数和返回值。无论是静态或者动态方法都必须这三个必要元素(<code>动态和静态的区别就在于在何时确定这些必要元素</code>)。<br>方法的执行包含编译和运行两个过程。</p>
<blockquote>
<ul>
<li>静态方法是在编译时已经确定了三个要素，且不能更改。若类型不对，就会直接发出警告。</li>
<li>而OC的动态方法可以直接跳过编译，在运行时才开始添加函数调用，决定执行方法的三个要素。这就是动态方法（至于怎么执行，下面开始讲解）</li>
</ul>
</blockquote>
<p>这三个元素是如何确定的呢？首先我们看一段示例代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Dog *aDog = [[Dog alloc]init];</div><div class="line">[aDog run];</div></pre></td></tr></table></figure>
<p>在执行方法时，是怎么确定的呢？<br>此时我们需要注意OC内部方法的实质：OC中，方法实现实质就是发送消息。<br><code>[aDog run];</code>代码的实质就是<code>[ objc_sendMsg]</code>，它会找到执行方法的三个要素，找到就按照规则执行。<br>发送消息是通过 <code>objc_send(id, SEL, ...)</code> 来实现的,它首先会在对象的类对象的 <code>cache</code>，<code>methodlist</code> 以及父类对象的 <code>cache</code>,<code>methodlist</code> 中依次查找 <code>SEL</code> 对应 的 <code>IMP</code>;<br>如果没有找到且实现了动态方法决议机制就会进行决议。</p>
<p>如果没有实现动态方法决议机制或决议失败且实现了消息转发机制就会进入消息转发流程,否则程序 crash。<br>也就是说如果同时提供了<code>动态方法决议</code>和<code>消息转发</code>,那么动态方法决议先于消息转发,只有当动态方法决议依然无法正确决议 <code>selector</code> 的 实现,才会尝试进行消息转发。当然，实际过程不可能那么简单，在开发语言之初，肯定会完善各种复杂场景和做了很多优化，接下来我们一起研究下OC对方法执行和扩展和优化：</p>
<blockquote>
<ul>
<li>第一步：先找方法</li>
<li>第二步：动态方法决议</li>
<li>第三部：消息转发</li>
<li>最后： 报错</li>
</ul>
</blockquote>
<h2 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h2><p>通常,给一个对象发送它不能处理的消息会得到出错提示,然而,<code>Objective-C</code>运行时系统在抛出错误之前, 会给消息接收对象发送一条特别的消息 <code>forwardInvocation</code> 来通该对象,该消息的唯一参数是个 <code>NSInvocation</code> 类型的对象——该对象封装了原始的消息和消息的参数。我们可以实现 <code>forwardInvocation:</code>方法来对不能处理的消息做一些默认的处理,也可以将消息转发给其他对 象来处理,而不抛出错误。</p>
<blockquote>
<ul>
<li>1,首先去该类的方法<code>cache</code>中查找,如果找到了就返回它;</li>
<li>2,如果没有找到,就去该类的方法列表中查找。如果在该类的方法列表中找到了,则将 <code>IMP</code> 返回,并将 它加入 <code>cache</code> 中缓存起来。根据最近使用原则,这个方法再次调用的可能性很大,缓存起来可以节省下次 调用再次查找的开销。</li>
<li>3,如果在该类的方法列表中没找到对应的<code>IMP</code>,在通过该类结构中的<code>super_class</code>指针在其父类结构的方法列表中去查找,直到在某个父类的方法列表中找到对应的<code>IMP</code>,返回它,并加入<code>cache</code>中;</li>
<li>4,如果在自身以及所有父类的方法列表中都没有找到对应的 <code>IMP</code>,则看是不是可以进行动态方法决议(后 面有专文讲述这个话题);</li>
<li>5,如果动态方法决议没能解决问题,进入下面要讲的消息转发流程。便利函数:我们可以通过 <code>NSObject</code> 的一些方法获取运行时信息或动态执行一些消息:</li>
</ul>
</blockquote>
<hr>
<p>class 返回对象的类:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">isKindOfClass,isMemberOfClass 检查对象是否在指定的类继承体系中;</div><div class="line">respondsToSelector 检查对象能否相应指定的消息;</div><div class="line">conformsToProtocol 检查对象是否实现了指定协议类的方法;</div><div class="line">methodForSelector 返回指定方法实现的地址；</div><div class="line">performSelector:withObject 执行 SEL 所指代的方法</div></pre></td></tr></table></figure></p>
<p> OC做为一门面向对象语言，自然具有面向对象的语言特性，如<code>封装</code>、<code>继承</code>、<code>多态</code>。他具有静态语言的特性(如C++)，又有动态语言的效率(动态绑定、动态加载等)。整体来说，确实是一门不错的编程语言。</p>
<hr>
<h2 id="OC的动态语言特性"><a href="#OC的动态语言特性" class="headerlink" title="OC的动态语言特性"></a>OC的动态语言特性</h2><p>现在，让我来想想OC的动态语言特性。OC的动态特性表现为了三个方面：<br><code>动态类型</code>、<code>动态绑定</code>、<code>动态加载</code>。<br>之所以叫做动态，是因为必须到运行时(<code>runtime</code>)才会做一些事情。</p>
<h3 id="（1）动态类型"><a href="#（1）动态类型" class="headerlink" title="（1）动态类型"></a>（1）动态类型</h3><p>动态类型，说简单点就是id类型。动态类型是跟静态类型相对的。像内置的明确的基本类型都属于静态类型(int、NSString等)。静态类型在编译的时候就能被识别出来。所以，若程序发生了类型不对应，编译器就会发出警告。而动态类型就编译器编译的时候是不能被识别的，要等到运行时(<code>runtime</code>)，即程序运行的时候才会根据语境来识别。所以这里面就有两个概念要分清：编译时跟运行时。</p>
<h3 id="（2）动态绑定"><a href="#（2）动态绑定" class="headerlink" title="（2）动态绑定"></a>（2）动态绑定</h3><p>动态绑定(<code>dynamic binding</code>)貌似比较难记忆，但事实上很简单，只需记住关键词<code>@selector/SEL</code>即可。先来看看“函数”，对于其他一些静态语言，比如c++,一般在编译的时候就已经将将要调用的函数的函数签名都告诉编译器了。静态的，不能改变。而在OC中，其实是没有函数的概念的，我们叫“消息机制”，所谓的函数调用就是给对象发送一条消息。这时，动态绑定的特性就来了。OC可以先跳过编译，到运行的时候才动态地添加函数调用，在运行时才决定要调用什么方法，需要传什么参数进去。这就是动态绑定，要实现他就必须用SEL变量绑定一个方法。最终形成的这个<code>SEL</code>变量就代表一个方法的引用。这里要注意一点：<code>SEL</code>并不是C里面的函数指针，虽然很像，但真心不是函数指针。<code>SEL</code>变量只是一个整数，他是该方法的ID。以前的函数调用，是根据函数名，也就是字符串去查找函数体。但现在，我们是根据一个ID整数来查找方法，整数的查找字自然要比字符串的查找快得多！所以，动态绑定的特定不仅方便，而且效率更高。</p>
<h3 id="（3）动态加载"><a href="#（3）动态加载" class="headerlink" title="（3）动态加载"></a>（3）动态加载</h3><p>动态加载就是根据需求动态地加载资源。我对动态加载比较陌生，所以就没什么可总结的啦。等以后慢慢完善。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>技术学习绝不能孤胆英雄独闯天涯，而应在一群人的交流碰撞，享受智慧火花的狂欢。<br>希望我的文章能成为你的盛宴，也渴望你的建议能成为我的大餐。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://betteris.top/趣谈iOS运行时之方法调用原理/" data-id="ck76887da000wlvx95v0trx36" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/runtime/">runtime</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-成员变量和属性的前世今生" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/成员变量和属性的前世今生/" class="article-date">
  <time datetime="2015-10-19T11:13:25.000Z" itemprop="datePublished">2015-10-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/成员变量和属性的前世今生/">成员变量和属性的前世今生</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h1><p>1.简述编译器的变化对@property的影响；<br>2.实际使用中@property和<code>成员变量+ @property + @synthesize 成员变量</code>的区别<br>3.<code>self.XXX</code>,<code>_XXX</code>,<code>self-&gt;XXX</code>的区别；<br>4.<a href="https://github.com/walkertop/--Demo.git" target="_blank" rel="external">Demo地址</a></p>
<h3 id="历史由来："><a href="#历史由来：" class="headerlink" title="历史由来："></a>历史由来：</h3><p>接触iOS的人都知道，<code>@property</code>声明的属性默认会生成一个_类型的成员变量，同时也会生成<code>setter/getter</code>方法。<br>但这只是在iOS5之后，苹果推出的一个新机制。看老代码时，经常看到一个大括号里面定义了成员变量，同时用了@property声明，而且还在@implementation中使用<code>@synthesize</code>方法。<br>如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">&#123;</div><div class="line">   // 1.声明成员变量</div><div class="line">    NSString *myString;  </div><div class="line"> &#125;</div><div class="line"> //2.在用@property</div><div class="line">@property(nonatomic, copy) NSString *myString;  </div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line">//3.最后在@implementation中用synthesize生成set方法</div><div class="line">@synthesize myString;   </div><div class="line">@end</div></pre></td></tr></table></figure>
<p>其实，发生这种状况根本原因是苹果将默认编译器从GCC转换为LLVM(<code>low level virtual machine</code>)，才不再需要为属性声明实例变量了。</p>
<p>在没有更改之前，属性的正常写法需要<code>成员变量+ @property + @synthesize 成员变量</code>三个步骤。<br>如果我们只写<code>成员变量+ @property</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@interface GBViewController :UIViewController</div><div class="line">&#123;</div><div class="line">    NSString *myString;</div><div class="line">&#125;</div><div class="line">@property (nonatomic, strong) NSString *myString;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p><strong>编译时会报警告:</strong><br><figure class="highlight plain"><figcaption><span>property 'myString' will use synthesized instance variable '_myString', not existing instance variable 'myString''```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">但更换为LLVM之后，编译器在编译过程中发现没有新的实例变量后，就会生成一个下划线开头的实例变量。因此现在我们不必在声明一个实例变量。（**注意：是不必要，不是不可以**）</div><div class="line">当然我们也熟知，`@property`声明的属性不仅仅默认给我们生成一个_类型的成员变量，同时也会生成`setter/getter`方法。</div><div class="line"></div><div class="line">在`.m`文件中，编译器也会自动的生成一个实例变量`_XXX`。那么在.m文件中可以直接的使用`_XXX`实例变量，也可以通过属性`self. XXX`。</div><div class="line"></div><div class="line">只是我们需要注意这里的`self.XXX`实际是调用`XXX`属性的`setter/getter`方法。这与C++中点的使用是有区别的，C++中的点可以直接访问成员变量(也就是实例变量)。</div><div class="line"></div><div class="line">**例如在OC中有如下代码**</div></pre></td></tr></table></figure></p>
<p>@interface MyViewController :UIViewController<br>{<br>    NSString *name;<br>}<br>@end<br><code>``
在这段代码里面只是声明了一个成员变量，并没有</code>setter/getter<code>方法。所以访问成员变量时，可以直接访问</code>name<code>，也可以像C++一样用</code>self-&gt;name<code>来访问，但绝对不能用</code>self.name`来访问。</p>
<blockquote>
<ul>
<li><strong>扩展</strong>:很多人觉得OC中的点语法比较奇怪，实际是OC设计人员有意为之。</li>
<li><code>点表达式(.)</code>看起来与C语言中的结构体访问以及java语言汇总的对象访问有点类似，如果点表达式出现在等号 <code>＝</code> 左边，调用该属性名称的<code>setter</code>方法。如果点表达式出现在<code>＝</code>右边，调用该属性名称的<code>getter</code>方法。</li>
<li>OC中<code>点表达式(.)</code>其实就是调用对象的<code>setter</code>和<code>getter</code>方法的一种快捷方式，<code>self.myString = @&quot;张三&quot;;</code>实际就是<code>[self setmyString:@&quot;张三&quot;];</code></li>
</ul>
</blockquote>
<p>首先我们要明白，<code>@synthesize</code> 生成了<code>setter/getter</code>方法。<br>虽然现在直接使用<code>@property</code>时，编译器会自动为你生成以下划线开头的实例变量<code>_myString</code>，不需要自己手动再去写实例变量。而且也不在.m文件中通过<code>@synthesize myString；</code>生成<code>setter/getter</code>方法。但在看老代码的时候，我们依旧可以看到有人使用<code>成员变量+ @synthesize 成员变量</code>的形式。</p>
<blockquote>
<p><strong>那么问题来了：</strong><br>我们能否认为新编译器LLVM下的<code>@property</code> == 老编译器GCC的 <code>成员变量+ @property + @synthesize 成员变量</code>呢？</p>
<p>答案是否定的，<br>因为<code>成员变量+ @property + @synthesize 成员变量</code>的形式，编译器不会帮我们生成<code>_成员变量</code>，因此不会操作<code>_成员变量</code>了；<br>同时<code>@synthesize</code> 还有一个作用，可以指定与属性对应的实例变量，<br>例如<code>@synthesize myString = xxx；</code><br>那么<code>self.myString</code>其实是操作的实例变量xxx，而非_String了。</p>
</blockquote>
<p>在<a href="https://github.com/walkertop/--Demo.git" target="_blank" rel="external">Demo</a>中会有非常详细的说明，欢迎下载和start。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>技术学习绝不能孤胆英雄独闯天涯，而应在一群人的交流碰撞，享受智慧火花的狂欢。<br>希望我的文章能成为你的盛宴，也渴望你的建议能成为我的大餐。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://betteris.top/成员变量和属性的前世今生/" data-id="ck76887d6000olvx9r3xt7ic8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/成员变量-属性/">成员变量 属性</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-category和extension史上最全攻略" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/category和extension史上最全攻略/" class="article-date">
  <time datetime="2015-09-29T04:23:39.000Z" itemprop="datePublished">2015-09-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/category和extension史上最全攻略/">category和extension史上最全攻略</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h2><p>在大型项目，企业级开发中多人同时维护同一个类，此时程序员A因为某项需求只想给当前类<code>currentClass</code>添加一个方法<code>newMethod</code>，那该怎么办呢？<br>最简单粗暴的方式是把<code>newMethod</code>添加到<code>currentClass</code>中，然后直接实现该方法就OK了。<br>但考虑到OC是单继承的，子类可以拥有父类的方法和属性。<br>如果把<code>newMethod</code>写到<code>currentClass</code>中，那么<code>currentClass</code>的子类也会拥有<code>newMethod</code>。但真正的需求是只需要<code>currentClass</code>拥有<code>newMethod</code>，而<code>currentClass</code>的子类不会拥有。<br>苹果为了解决这个问题，就引入了分类（Category）的概念。</p>
<h2 id="分类（Category）："><a href="#分类（Category）：" class="headerlink" title="分类（Category）："></a>分类（Category）：</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>分类（Category）是OC中的特有语法，它是表示一个指向分类的结构体的指针。原则上它只能增加方法，不能增加成员（实例）变量。具体原因看源码组成:</p>
<h3 id="Category源码："><a href="#Category源码：" class="headerlink" title="Category源码："></a>Category源码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Category</div><div class="line">Category 是表示一个指向分类的结构体的指针，其定义如下：</div><div class="line">typedef struct objc_category *Category;</div><div class="line">struct objc_category &#123;</div><div class="line">  char *category_name                          OBJC2_UNAVAILABLE; // 分类名</div><div class="line">  char *class_name                             OBJC2_UNAVAILABLE; // 分类所属的类名</div><div class="line">  struct objc_method_list *instance_methods    OBJC2_UNAVAILABLE; // 实例方法列表</div><div class="line">  struct objc_method_list *class_methods       OBJC2_UNAVAILABLE; // 类方法列表</div><div class="line">  struct objc_protocol_list *protocols         OBJC2_UNAVAILABLE; // 分类所实现的协议列表</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">通过上面我们可以发现，这个结构体主要包含了分类定义的实例方法与类方法，其中instance_methods 列表是 objc_class 中方法列表的一个子集，而class_methods列表是元类方法列表的一个子集。</div><div class="line">但这个结构体里面</div><div class="line"></div><div class="line">根本没有属性列表，</div><div class="line">根本没有属性列表，</div><div class="line">根本没有属性列表。</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：<br>1.分类是用于给原有类添加方法的,因为分类的结构体指针中，没有属性列表，只有方法列表。所以&lt; <strong>原则上讲它只能添加方法, 不能添加属性(成员变量),实际上可以通过其它方式添加属性</strong>&gt; ;<br>2.分类中的可以写@property, 但不会生成<code>setter/getter</code>方法, 也不会生成实现以及私有的成员变量（编译时会报警告）;<br>3.可以在分类中访问原有类中.h中的属性;<br>4.如果分类中有和原有类同名的方法, 会优先调用分类中的方法, 就是说会忽略原有类的方法。所以同名方法调用的优先级为 <code>分类 &gt; 本类 &gt; 父类</code>。因此在开发中尽量不要覆盖原有类;<br>5.如果多个分类中都有和原有类中同名的方法, 那么调用该方法的时候执行谁由编译器决定；编译器会执行最后一个参与编译的分类中的方法。</p>
</blockquote>
<h3 id="分类格式："><a href="#分类格式：" class="headerlink" title="分类格式："></a>分类格式：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@interface 待扩展的类（分类的名称）</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation 待扩展的名称（分类的名称）</div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="实际代码如下："><a href="#实际代码如下：" class="headerlink" title="实际代码如下："></a>实际代码如下：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//  Programmer+Category.h文件中</div><div class="line">@interface Programmer (Category)</div><div class="line"></div><div class="line">@property(nonatomic,copy) NSString *nameWithSetterGetter;           //设置setter/getter方法的属性</div><div class="line"></div><div class="line">@property(nonatomic,copy) NSString *nameWithoutSetterGetter;        //不设置setter/getter方法的属性（注意是可以写在这，而且编译只会报警告，运行不报错）</div><div class="line"></div><div class="line">- (void) programCategoryMethod;                                     //分类方法</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">//  Programmer+Category.m文件中</div></pre></td></tr></table></figure>
<p><strong>那么问题来了：</strong></p>
<blockquote>
<p>为什么在分类中声明属性时，运行不会出错呢？<br>既然分类不让添加属性，那为什么我写了@property仍然还以编译通过呢？</p>
</blockquote>
<p> <strong>接下来我们探究下分类不能添加属性的实质原因：</strong></p>
<blockquote>
<p>我们知道在一个类中用@property声明属性，编译器会自动帮我们生成<code>_成员变量</code>和<code>setter/getter</code>，但分类的指针结构体中，根本没有属性列表。所以在分类中用@property声明属性，既无法生成<code>_成员变量</code>也无法生成<code>setter/getter</code>。<br>因此结论是：我们可以用@property声明属性，编译和运行都会通过，只要不使用程序也不会崩溃。但如果调用了<code>_成员变量</code>和<code>setter/getter</code>方法，报错就在所难免了。</p>
</blockquote>
<hr>
<blockquote>
<p><strong>报错原因如下</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//普通声明，无setter/getter</div><div class="line">//    programmer.nameWithoutSetterGetter = @&quot;无setter/getter&quot;;    //调用setter，编译成功，运行报错为：（-[Programmer setNameWithSetterGetter:]: unrecognized selector sent to instance 0x7f9de358fd70&apos;）</div><div class="line">    </div><div class="line">//    NSLog(@&quot;%@&quot;,programmer.nameWithoutSetterGetter);           //调用getter，编译成功，运行报错为-[Programmer setNameWithSetterGetter:]: unrecognized selector sent to instance 0x7fe22be11ea0&apos;</div><div class="line"></div><div class="line">//    NSLog(@&quot;%@&quot;,_nameWithoutSetterGetter);        //这是调用_成员变量,错误提示为：（Use of undeclared identifier &apos;_nameWithoutSetterGetter&apos;）</div></pre></td></tr></table></figure>
<p>那接下来我们继续思考:<br>既然报错的根本原因是使用了系统没有生成的<code>setter/getter</code>方法，可不可以在手动添加<code>setter/getter</code>来避免崩溃，完成调用呢？<br>其实是可以的。由于OC是动态语言，方法真正的实现是通过<code>runtime</code>完成的，虽然系统不给我们生成<code>setter/getter</code>，但我们可以通过<code>runtime</code>手动添加<code>setter/getter</code>方法。那具体怎么实现呢？</p>
<h3 id="代码实现如下"><a href="#代码实现如下" class="headerlink" title="代码实现如下:"></a>代码实现如下:</h3><p>按照这个思路，我们通过运行时手动添加这个方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line"></div><div class="line">static NSString *nameWithSetterGetterKey = @&quot;nameWithSetterGetterKey&quot;;   //定义一个key值</div><div class="line">@implementation Programmer (Category)</div><div class="line"></div><div class="line">//运行时实现setter方法</div><div class="line">- (void)setNameWithSetterGetter:(NSString *)nameWithSetterGetter &#123;</div><div class="line">        objc_setAssociatedObject(self, &amp;nameWithSetterGetterKey, nameWithSetterGetter, OBJC_ASSOCIATION_COPY);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//运行时实现getter方法</div><div class="line">- (NSString *)nameWithSetterGetter &#123;</div><div class="line">    return objc_getAssociatedObject(self, &amp;nameWithSetterGetterKey);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="实际使用效果"><a href="#实际使用效果" class="headerlink" title="实际使用效果"></a>实际使用效果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//通过runtime实现了setter/getter</div><div class="line">    programmer.nameWithSetterGetter = @&quot;有setter/getter&quot;;    //调用setter，成功</div><div class="line">    NSLog(@&quot;%@&quot;,programmer.nameWithSetterGetter);            //调用getter，成功</div><div class="line">//    NSLog(@&quot;%@&quot;,_nameWithSetterGetter); //这是调用_成员变量，错误提示为：（Use of undeclared identifier &apos;_nameWithSetterGetter&apos;）</div></pre></td></tr></table></figure>
<p><strong>问题解决。</strong></p>
<blockquote>
<p><strong>但是注意，以上代码仅仅是手动实现了</strong><code>setter/getter</code><strong>方法，但调用</strong><code>_成员变量</code><strong>依然报错。</strong></p>
</blockquote>
<h2 id="类扩展（Class-Extension）"><a href="#类扩展（Class-Extension）" class="headerlink" title="类扩展（Class Extension）"></a>类扩展（Class Extension）</h2><p>Extension是Category的一个特例。类扩展与分类相比只少了分类的名称，所以称之为“匿名分类”。<br>其实开发当中，我们几乎天天在使用。对于有些人来说像是最熟悉的陌生人。</p>
<h3 id="类扩展格式："><a href="#类扩展格式：" class="headerlink" title="类扩展格式："></a>类扩展格式：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@interface XXX ()</div><div class="line">//私有属性</div><div class="line">//私有方法（如果不实现，编译时会报警,Method definition for &apos;XXX&apos; not found）</div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><blockquote>
<p>为一个类添加额外的原来没有变量，方法和属性<br>一般的类扩展写到<code>.m</code>文件中<br>一般的私有属性写到<code>.m</code>文件中的类扩展中</p>
</blockquote>
<hr>
<h2 id="类别与类扩展的区别："><a href="#类别与类扩展的区别：" class="headerlink" title="类别与类扩展的区别："></a>类别与类扩展的区别：</h2><blockquote>
<p>①类别中原则上只能增加方法（能添加属性的的原因只是通过<code>runtime</code>解决无<code>setter/getter</code>的问题而已）；<br>②类扩展不仅可以增加方法，还可以增加实例变量（或者属性），只是该实例变量默认是@private类型的（<br>用范围只能在自身类，而不是子类或其他地方）；<br>③类扩展中声明的方法没被实现，编译器会报警，但是类别中的方法没被实现编译器是不会有任何警告的。这是因为<strong>类扩展是在编译阶段被添加到类中，而类别是在运行时添加到类中</strong>。<br>④类扩展不能像类别那样拥有独立的实现部分（@implementation部分），也就是说，类扩展所声明的方法必须依托对应类的实现部分来实现。<br>⑤定义在 .m 文件中的类扩展方法为私有的，定义在 .h 文件（头文件）中的类扩展方法为公有的。类扩展是在 .m 文件中声明私有方法的非常好的方式。</p>
</blockquote>
<h2 id="点击下载Demo"><a href="#点击下载Demo" class="headerlink" title="点击下载Demo"></a><a href="https://github.com/walkertop/CategoryAndExtension--Demo" target="_blank" rel="external">点击下载Demo</a></h2><h2 id="最后总结："><a href="#最后总结：" class="headerlink" title="最后总结："></a>最后总结：</h2><p>关于分类，类扩展等问题，在很多概念性的东西网上讲解的很是模糊，而且在实际应用的背后的原理上也少有展开。作者写这篇文章的目的就是想让读者对分类，类扩展等常见的问题有个清晰的认识，免了看了记不住，记住又记不对，记对了又不明白原因。<br>在实际开发中，很多工具类都是分类，类扩展的实际应用，所以笔者后续会在我的个人GitHub上放出工具类，欢迎start和follow。<br>文章是本人通过实际代码和自己的开发经验整理而成，如果你喜欢我的文章，欢迎喜欢和打赏。技术的进步成长需要交流碰撞，也期待你的留言评论，不要只做一个MARK党。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://betteris.top/category和extension史上最全攻略/" data-id="ck76887cx000blvx9mjujakvf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/category/">category</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-深入runtime探究KVO" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/深入runtime探究KVO/" class="article-date">
  <time datetime="2015-09-29T04:18:27.000Z" itemprop="datePublished">2015-09-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/深入runtime探究KVO/">深入runtime探究KVO</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Objective-C 中的键(key)-值(value)观察(KVO)并不是什么新鲜事物,它来源于设计模式中的<code>观察者模式</code>,其基本思想就是:</p>
<blockquote>
<p>一个目标对象管理所有依赖于它的观察者对象,并在它自身的状态改变时主动通知观察者对象。这个主动通知通常是通过调用各观察者对象所提供的接口方法来实现的。观察者模式较完美地将目标对象与观察者对象解耦。</p>
</blockquote>
<p>在 Objective-C 中有两种使用键值观察的方式:手动或自动,此外还支持注册依赖键(即一个键依赖于 其他键,其他键的变化也会作用到该键)。下面将一一讲述这些,并会深入 Objective-C 内部一窥键值 观察是如何实现的。</p>
<hr>
<h2 id="观察者（Observer）"><a href="#观察者（Observer）" class="headerlink" title="观察者（Observer）"></a>观察者（Observer）</h2><blockquote>
<p><strong>观察者（Observer）</strong><br>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。<br>在 <code>Cocoa Touch</code> 框架中通知和 <code>KVO</code> 都实现了观察者模式。<strong>通知是由一个中心对象为所有观察者提供变更通知，<code>KVO</code> 是被观察的对象直接向观察者发送通知。</strong><br>如上图，<code>Subject</code> 的值改变时，通知观察者 <code>ObserverA</code>，<code>ObserverB</code>，<code>ObserverC</code>，我的数据改变了，依赖我的你们需要更新状态了。<br><code>被观察者不需要知道有多少个观察者和观察者的更新细节，降低被观察者和观察者之间的耦合</code>。</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/1467716-696c1f5f6fb7cab7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="observer.png"></p>
<h2 id="运用键值观察"><a href="#运用键值观察" class="headerlink" title="运用键值观察"></a>运用键值观察</h2><h3 id="1-注册与解除注册"><a href="#1-注册与解除注册" class="headerlink" title="1,注册与解除注册"></a>1,注册与解除注册</h3><p>如果我们已经有了包含可供键值观察属性的类,那么就可以通过在该类的对象(被观察对象)上调用名 为 NSKeyValueObserverRegistration 的 category 方法将观察者对象与被观察者对象注册与解除 注册:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath opt ions:(NSKeyValueObservingOptions)options context:(void *)context;</div><div class="line">- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath;</div></pre></td></tr></table></figure>
<p>这两个方法的定义在 <code>Foundation/NSKeyValueObserving.h</code> 中,<code>NSObject</code>,<code>NSArray</code>,<code>NSSet</code> 均实现了以上方法,因此我们不仅可以观察普通对象,还可以观察数组或结合类对象。在该头文件中,我们还 可以看到 NSObject 还实现了 <code>NSKeyValueObserverNotification</code> 的 <code>category</code> 方法(更多类似方 法,请查看该头文件):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (void)willChangeValueForKey:(NSString *)key;</div><div class="line">- (void)didChangeValueForKey:(NSString *)key;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong>不要忘记解除注册,否则会导致资源泄露。</p>
</blockquote>
<h3 id="2-设置属性"><a href="#2-设置属性" class="headerlink" title="2,设置属性"></a>2,设置属性</h3><p>将观察者与被观察者注册好之后,就可以对观察者对象的属性进行操作,这些变更操作就会被通知给观察 者对象。注意,只有遵循 KVO 方式来设置属性,观察者对象才会获取通知,也就是说遵循使用属性的 setter 方法,或通过 key-path 来设置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//必须是set方法</div><div class="line">target.age = 30;</div><div class="line">[target setAge:30];</div><div class="line">[target setValue:[NSNumber numberWithInt:30] forKey:@&quot;age&quot;];</div></pre></td></tr></table></figure>
<h3 id="3-处理变更通知"><a href="#3-处理变更通知" class="headerlink" title="3,处理变更通知"></a>3,处理变更通知</h3><p>观察者需要实现名为 <code>NSKeyValueObserving</code> 的 <code>category</code> 方法来处理收到的变更通知:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong>在这里<code>change</code> 这个字典保存了变更信息,具体是哪些信息取决于注册时 的 <code>NSKeyValueObservingOptions</code>。</p>
</blockquote>
<h2 id="KVO的内部实现原理："><a href="#KVO的内部实现原理：" class="headerlink" title="KVO的内部实现原理："></a>KVO的内部实现原理：</h2><p>KVO是基于<code>runtime</code>机制实现的，当某个类的属性对象第一次被观察时，系统就会在运行期间动态地创建该类的一个派生类，在这个派生类中重写基类的任何被观察属性的<code>setter</code>方法。派生类在被重写的setter方法内实现真正的通知机制<br>如果原类为<code>Person</code>，那么生成的派生类名为<code>NSKVONotifying_Person</code>。</p>
<p>我们知道，每一个类中都有一个<code>isa</code>指针指向当前类，所有系统就是在当一个类的对象第一次被观察的时候，系统就会偷偷将<code>isa</code>指针指向动态生成的派生类，从而在被监听属性赋值时被执行的是派生类的<code>setter</code>方法<br>键值观察通知依赖于<code>NSObject</code> 的两个方法: <code>willChangeValueForKey:</code> 和 <code>didChangevlueForKey:</code>;在一个被观察属性发生改变之前， <code>willChangeValueForKey:</code> 一定会被调用，这就 会记录旧的值。而当改变发生后，<code>didChangeValueForKey:</code> 会被调用，继而 <code>observeValueForKey: ofObject: change: context:</code> 也会被调用。</p>
<blockquote>
<p><strong>补充：</strong>KVO的这套实现机制中苹果还偷偷重写了class方法以“欺骗”外部调用者，让我们误认为还是使用的当前类，然后系统将这个对象的 isa 指针指向这个新诞生的派生类,因此这个对象就成为该派生类的对象了,因而在该对象上对 <code>setter</code> 的调 用就会调用重写的 <code>setter</code>,从而激活键值通知机制。此外,派生类还重写了 <code>dealloc</code> 方法来释放资源。</p>
</blockquote>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>技术学习绝不能孤胆英雄独闯天涯，而应在一群人的交流碰撞，享受智慧火花的狂欢。<br>希望我的文章能成为你的盛宴，也渴望你的建议能成为我的大餐。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://betteris.top/深入runtime探究KVO/" data-id="ck76887d5000mlvx99ggcs4bk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/runtime-KVO/">runtime, KVO</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/KVC-Runtime/">KVC Runtime</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RAC/">RAC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RAC-MVVM/">RAC MVVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/YYModel/">YYModel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/category/">category</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS-RunLoop/">iOS RunLoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/runtime/">runtime</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/runtime-KVO/">runtime, KVO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/setter-getter/">setter/getter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/swift/">swift</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/成员变量-属性/">成员变量 属性</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/读书笔记/">读书笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/KVC-Runtime/" style="font-size: 10px;">KVC Runtime</a> <a href="/tags/RAC/" style="font-size: 20px;">RAC</a> <a href="/tags/RAC-MVVM/" style="font-size: 10px;">RAC MVVM</a> <a href="/tags/YYModel/" style="font-size: 10px;">YYModel</a> <a href="/tags/category/" style="font-size: 10px;">category</a> <a href="/tags/iOS-RunLoop/" style="font-size: 10px;">iOS RunLoop</a> <a href="/tags/runtime/" style="font-size: 20px;">runtime</a> <a href="/tags/runtime-KVO/" style="font-size: 10px;">runtime, KVO</a> <a href="/tags/setter-getter/" style="font-size: 10px;">setter/getter</a> <a href="/tags/swift/" style="font-size: 10px;">swift</a> <a href="/tags/成员变量-属性/" style="font-size: 10px;">成员变量 属性</a> <a href="/tags/读书笔记/" style="font-size: 10px;">读书笔记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/swift的数据类型到底是什么尿性-说点别人没讲明白的）/">swift的数据类型到底是什么尿性 (说点别人没讲明白的）</a>
          </li>
        
          <li>
            <a href="/0821杂谈/">0821杂谈</a>
          </li>
        
          <li>
            <a href="/紧张兮兮的一个月/">紧张兮兮的一个月</a>
          </li>
        
          <li>
            <a href="/《把时间当作朋友》读书笔记/">《把时间当作朋友》读书笔记</a>
          </li>
        
          <li>
            <a href="/解释automaticallyAdjustsScrollViewInsets，extendedLayoutIncludesOpaqueBars，edgesForExtendedLayout的不同/">解释automaticallyAdjustsScrollViewInsets，extendedLayoutIncludesOpaqueBars，edgesForExtendedLayout的不同</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Walker Guo<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>