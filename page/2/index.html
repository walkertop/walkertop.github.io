<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Walker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Better is top!">
<meta property="og:type" content="website">
<meta property="og:title" content="Walker">
<meta property="og:url" content="http://betteris.top/page/2/index.html">
<meta property="og:site_name" content="Walker">
<meta property="og:description" content="Better is top!">
<meta property="article:author" content="Walker Guo">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Walker" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Walker</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Better is top!</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://betteris.top"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-三分钟教会你runtime获取属性和成员变量" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E4%B8%89%E5%88%86%E9%92%9F%E6%95%99%E4%BC%9A%E4%BD%A0runtime%E8%8E%B7%E5%8F%96%E5%B1%9E%E6%80%A7%E5%92%8C%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/" class="article-date">
  <time datetime="2016-05-09T02:10:59.000Z" itemprop="datePublished">2016-05-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E4%B8%89%E5%88%86%E9%92%9F%E6%95%99%E4%BC%9A%E4%BD%A0runtime%E8%8E%B7%E5%8F%96%E5%B1%9E%E6%80%A7%E5%92%8C%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/">三分钟教会你runtime获取属性和成员变量</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><blockquote>
<ul>
<li>成员变量和属性到底是什么？</li>
<li>怎么通过runtime获取属性？</li>
<li>怎么通过runtime获取成员变量？ </li>
<li>成员变量和属性的区别？</li>
<li>实际应用场景是什么？</li>
</ul>
</blockquote>
<h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><h3 id="1、成员变量的定义"><a href="#1、成员变量的定义" class="headerlink" title="1、成员变量的定义"></a>1、成员变量的定义</h3><blockquote>
<p>Ivar: 实例变量类型，是一个指向<code>objc_ivar</code>结构体的指针<br><code>typedef struct objc_ivar *Ivar;</code></p>
</blockquote>
<h3 id="2、相关函数"><a href="#2、相关函数" class="headerlink" title="2、相关函数"></a>2、相关函数</h3><blockquote>
<p>// 获取所有成员变量<br><code>class_copyIvarList</code><br>// 获取成员变量名<br><code>ivar_getName</code><br>// 获取成员变量类型编码<br><code>ivar_getTypeEncoding</code><br>// 获取指定名称的成员变量<br><code>class_getInstanceVariable</code><br>// 获取某个对象成员变量的值<br><code>object_getIvar</code><br>// 设置某个对象成员变量的值<br><code>object_setIvar</code></p>
</blockquote>
<p><strong>说明：</strong><br><code>property_getAttributes</code>函数返回<code>objc_property_attribute_t</code>结构体列表，<code>objc_property_attribute_t</code>结构体包含<code>name</code>和<code>value</code>，常用的属性如下：</p>
<p>属性类型  <code>name</code>值：T                                     <code>value：</code>变化<br>编码类型  <code>name</code>值：C(copy) &amp;(strong) W(weak)空(assign) 等 <code>value：</code>无<br>非/原子性 <code>name</code>值：空(atomic) N(Nonatomic)                <code>value：</code>无<br>变量名称  <code>name</code>值：V                                        <code>value：</code>变化</p>
<p>使用<code>property_getAttributes</code>获得的描述是<code>property_copyAttributeList</code>能获取到的所有的<code>name</code>和<code>value</code>的总体描述，如 T@”NSDictionary”,C,N,V_dict1</p>
<h3 id="3、实例应用"><a href="#3、实例应用" class="headerlink" title="3、实例应用"></a>3、实例应用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--Person.h文件--&gt;</span><br><span class="line">@interface Person : NSObject</span><br><span class="line">&#123;</span><br><span class="line">    NSString *address;</span><br><span class="line">&#125;</span><br><span class="line">@property(nonatomic,strong)NSString *name;</span><br><span class="line">@property(nonatomic,assign)NSInteger age;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;遍历获取Person类所有的成员变量IvarList</span><br><span class="line">- (void) getAllIvarList &#123;</span><br><span class="line">    unsigned int methodCount &#x3D; 0;</span><br><span class="line">    Ivar * ivars &#x3D; class_copyIvarList([Person class], &amp;methodCount);</span><br><span class="line">    for (unsigned int i &#x3D; 0; i &lt; methodCount; i ++) &#123;</span><br><span class="line">        Ivar ivar &#x3D; ivars[i];</span><br><span class="line">        const char * name &#x3D; ivar_getName(ivar);</span><br><span class="line">        const char * type &#x3D; ivar_getTypeEncoding(ivar);</span><br><span class="line">        NSLog(@&quot;Person拥有的成员变量的类型为%s，名字为 %s &quot;,type, name);</span><br><span class="line">    &#125;</span><br><span class="line">    free(ivars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--打印结果--&gt;</span><br><span class="line">2016-06-15 20:26:39.412 demo-Cocoa之method swizzle[17798:2565569] Person拥有的成员变量的类型为@&quot;NSString&quot;，名字为 address </span><br><span class="line">2016-06-15 20:26:39.413 demo-Cocoa之method swizzle[17798:2565569] Person拥有的成员变量的类型为@&quot;NSString&quot;，名字为 _name </span><br><span class="line">2016-06-15 20:26:39.413 demo-Cocoa之method swizzle[17798:2565569] Person拥有的成员变量的类型为q，名字为 _age</span><br></pre></td></tr></table></figure>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="1、属性的定义"><a href="#1、属性的定义" class="headerlink" title="1、属性的定义"></a>1、属性的定义</h3><blockquote>
<p><code>objc_property_t</code>：声明的属性的类型，是一个指向<code>objc_property</code>结构体的指针<br><code>typedef struct objc_property *objc_property_t;</code></p>
</blockquote>
<h3 id="2、相关函数-1"><a href="#2、相关函数-1" class="headerlink" title="2、相关函数"></a>2、相关函数</h3><blockquote>
<p>// 获取所有属性<br><code>class_copyPropertyList</code><br>说明：使用<code>class_copyPropertyList</code>并不会获取无<code>@property</code>声明的成员变量<br>// 获取属性名<br><code>property_getName</code><br>// 获取属性特性描述字符串<br><code>property_getAttributes</code><br>// 获取所有属性特性<br><code>property_copyAttributeList</code> </p>
</blockquote>
<h3 id="3、实例应用-1"><a href="#3、实例应用-1" class="headerlink" title="3、实例应用"></a>3、实例应用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--Person.h文件--&gt;</span><br><span class="line">@interface Person : NSObject</span><br><span class="line">&#123;</span><br><span class="line">    NSString *address;</span><br><span class="line">&#125;</span><br><span class="line">@property(nonatomic,strong)NSString *name;</span><br><span class="line">@property(nonatomic,assign)NSInteger age;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;遍历获取所有属性Property</span><br><span class="line">- (void) getAllProperty &#123;</span><br><span class="line">    unsigned int propertyCount &#x3D; 0;</span><br><span class="line">    objc_property_t *propertyList &#x3D; class_copyPropertyList([Person class], &amp;propertyCount);</span><br><span class="line">    for (unsigned int i &#x3D; 0; i &lt; propertyCount; i++ ) &#123;</span><br><span class="line">        objc_property_t *thisProperty &#x3D; propertyList[i];</span><br><span class="line">        const char* propertyName &#x3D; property_getName(*thisProperty);</span><br><span class="line">        NSLog(@&quot;Person拥有的属性为: &#39;%s&#39;&quot;, propertyName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--打印结果--&gt;</span><br><span class="line">2016-06-15 20:25:19.653 demo-Cocoa之method swizzle[17778:2564081] Person拥有的属性为: &#39;name&#39;</span><br><span class="line">2016-06-15 20:25:19.653 demo-Cocoa之method swizzle[17778:2564081] Person拥有的属性为: &#39;age&#39;</span><br></pre></td></tr></table></figure>
<h2 id="应用具体场景"><a href="#应用具体场景" class="headerlink" title="应用具体场景"></a>应用具体场景</h2><h3 id="1、Json到Model的转化"><a href="#1、Json到Model的转化" class="headerlink" title="1、Json到Model的转化"></a>1、Json到Model的转化</h3><p>在开发中相信最常用的就是接口数据需要转化成Model了（当然如果你是直接从Dict取值的话。。。），很多开发者也都使用著名的第三方库如<code>JsonModel</code>、<code>Mantle</code>或<code>MJExtension</code>等，如果只用而不知其所以然，那真和“搬砖”没啥区别了，下面我们使用runtime去解析json来给Model赋值。</p>
<p>原理描述：用runtime提供的函数遍历Model自身所有属性，如果属性在json中有对应的值，则将其赋值。</p>
<p>核心方法：在NSObject的分类中添加方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithDict:(NSDictionary *)dict &#123;</span><br><span class="line"> </span><br><span class="line">    if (self &#x3D; [self init]) &#123;</span><br><span class="line">        &#x2F;&#x2F;(1)获取类的属性及属性对应的类型</span><br><span class="line">        NSMutableArray * keys &#x3D; [NSMutableArray array];</span><br><span class="line">        NSMutableArray * attributes &#x3D; [NSMutableArray array];</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * 例子</span><br><span class="line">         * name &#x3D; value3 attribute &#x3D; T@&quot;NSString&quot;,C,N,V_value3</span><br><span class="line">         * name &#x3D; value4 attribute &#x3D; T^i,N,V_value4</span><br><span class="line">         *&#x2F;</span><br><span class="line">        unsigned int outCount;</span><br><span class="line">        objc_property_t * properties &#x3D; class_copyPropertyList([self class], &amp;outCount);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; outCount; i ++) &#123;</span><br><span class="line">            objc_property_t property &#x3D; properties[i];</span><br><span class="line">            &#x2F;&#x2F;通过property_getName函数获得属性的名字</span><br><span class="line">            NSString * propertyName &#x3D; [NSString stringWithCString:property_getName(property) encoding:NSUTF8StringEncoding];</span><br><span class="line">            [keys addObject:propertyName];</span><br><span class="line">            &#x2F;&#x2F;通过property_getAttributes函数可以获得属性的名字和@encode编码</span><br><span class="line">            NSString * propertyAttribute &#x3D; [NSString stringWithCString:property_getAttributes(property) encoding:NSUTF8StringEncoding];</span><br><span class="line">            [attributes addObject:propertyAttribute];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;立即释放properties指向的内存</span><br><span class="line">        free(properties);</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;(2)根据类型给属性赋值</span><br><span class="line">        for (NSString * key in keys) &#123;</span><br><span class="line">            if ([dict valueForKey:key] &#x3D;&#x3D; nil) continue;</span><br><span class="line">            [self setValue:[dict valueForKey:key] forKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读者可以进一步思考：</p>
<p>如何识别基本数据类型的属性并处理<br>空（nil，null）值的处理<br>json中嵌套json（Dict或Array）的处理</p>
<p>尝试解决以上问题，你也能写出属于自己的功能完备的Json转Model库。</p>
<h3 id="2、快速归档"><a href="#2、快速归档" class="headerlink" title="2、快速归档"></a>2、快速归档</h3><p>有时候我们要对一些信息进行归档，如用户信息类UserInfo，这将需要重写<code>initWithCoder</code>和<code>encodeWithCoder</code>方法，并对每个属性进行<code>encode</code>和<code>decode</code>操作。那么问题来了：当属性只有几个的时候可以轻松写完，如果有几十个属性呢？那不得写到天荒地老.</p>
<p>原理描述：用runtime提供的函数遍历Model自身所有属性，并对属性进行<code>encode</code>和<code>decode</code>操作。</p>
<p>核心方法：在Model的基类中重写方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (id)initWithCoder:(NSCoder *)aDecoder &#123;</span><br><span class="line">    if (self &#x3D; [super init]) &#123;</span><br><span class="line">        unsigned int outCount;</span><br><span class="line">        Ivar * ivars &#x3D; class_copyIvarList([self class], &amp;outCount);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; outCount; i ++) &#123;</span><br><span class="line">            Ivar ivar &#x3D; ivars[i];</span><br><span class="line">            NSString * key &#x3D; [NSString stringWithUTF8String:ivar_getName(ivar)];</span><br><span class="line">            [self setValue:[aDecoder decodeObjectForKey:key] forKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)encodeWithCoder:(NSCoder *)aCoder &#123;</span><br><span class="line">    unsigned int outCount;</span><br><span class="line">    Ivar * ivars &#x3D; class_copyIvarList([self class], &amp;outCount);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; outCount; i ++) &#123;</span><br><span class="line">        Ivar ivar &#x3D; ivars[i];</span><br><span class="line">        NSString * key &#x3D; [NSString stringWithUTF8String:ivar_getName(ivar)];</span><br><span class="line">        [aCoder encodeObject:[self valueForKey:key] forKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、访问私有变量"><a href="#3、访问私有变量" class="headerlink" title="3、访问私有变量"></a>3、访问私有变量</h3><p>我们知道，OC中没有真正意义上的私有变量和方法，要让成员变量私有，要放在m文件中声明，不对外暴露。如果我们知道这个成员变量的名称，可以通过runtime获取成员变量，再通过<code>getIvar</code>来获取它的值。</p>
<p>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ivar ivar &#x3D; class_getInstanceVariable([Model class], &quot;_str1&quot;);</span><br><span class="line">NSString * str1 &#x3D; object_getIvar(model, ivar);</span><br></pre></td></tr></table></figure>







      
    </div>
    <footer class="article-footer">
      <a data-url="http://betteris.top/%E4%B8%89%E5%88%86%E9%92%9F%E6%95%99%E4%BC%9A%E4%BD%A0runtime%E8%8E%B7%E5%8F%96%E5%B1%9E%E6%80%A7%E5%92%8C%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/" data-id="ck55j78ed000kakx9hc7ngvt6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/runtime/" rel="tag">runtime</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-RAC-MVVM封装的网络请求" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/RAC-MVVM%E5%B0%81%E8%A3%85%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/" class="article-date">
  <time datetime="2016-03-22T04:11:29.000Z" itemprop="datePublished">2016-03-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/RAC-MVVM%E5%B0%81%E8%A3%85%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/">RAC+MVVM封装的网络请求</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-MVVM-代替-MVC-原因"><a href="#1-MVVM-代替-MVC-原因" class="headerlink" title="1.MVVM 代替 MVC 原因"></a>1.MVVM 代替 MVC 原因</h3><p>无论MVC还是MVVM，包括其他设计模式，核心目的是为了提高代码的简洁性，降低耦合度。<br>简单点说就是让专门的人去做专门的事情。<br>比如MVC模式中，</p>
<blockquote>
<ul>
<li>M (model)</li>
<li>V (view)</li>
<li>C (controller)</li>
</ul>
</blockquote>
<p>但在MVC中，通过网络请求回来的数据会放到Model中，作为数据源来调用和处理。<br>但还是存在控制器中文件很大的问题。很多业务逻辑都写到了控制器上了，不利于程序之间的解耦，而且在比较大的项目中，代码的可读性也比较差，而MVVM的引入大大减少了这个问题，会让C释放释放出来，关于视图方面的业务逻辑交给VM处理，C只用来解决控制器之间的连接问题。</p>
<h3 id="2-RAC如何处理和传输数据"><a href="#2-RAC如何处理和传输数据" class="headerlink" title="2.RAC如何处理和传输数据"></a>2.RAC如何处理和传输数据</h3><p>那在RAC中怎么处理和传送数据呢？<br>RAC最核心的内容是信号。我们可以把网络请求回来的数据通过信号传递和发送出去。<br>我们把网络请求回来的数据叫做<code>responseObject</code>。<br>基于RAC(  想深入探究 RAC 原理可点击<a href="http://www.jianshu.com/p/7cf4754cebee" target="_blank" rel="noopener">史上最全ReactiveCocoa(RAC)之信号类源码解析</a>)的知识，我们让订阅者发送数据，然后让信号接收数据，便完成数据的传递。<br>同时RAC中有<code>RACCommand</code>的类，负责处理事件。<br>所有总体可以分为三步：</p>
<ul>
<li><ol>
<li>网络请求，获得数据<code>responseObject</code>；</li>
</ol>
</li>
<li><ol start="2">
<li>订阅者将<code>responseObject</code>发送出去；</li>
</ol>
</li>
<li><ol start="3">
<li>信号订阅信号（接收发送处理的数据）。</li>
</ol>
</li>
</ul>
<h3 id="3-代码实例"><a href="#3-代码实例" class="headerlink" title="3.代码实例"></a>3.代码实例</h3><p>至于代码层面是怎么解决这三个方面的问题呢?</p>
<p>我们假设一个使用场景：<br>豆瓣上有开放的API，当我们查询图书的时候，当搜索”美女”关键词的时候，会出现很多关于美女的图书。<br>然后将其显示在tableView上。</p>
<p>主要的业务逻辑包括：</p>
<blockquote>
<ul>
<li><ol>
<li>通过AFN请求数据</li>
</ol>
</li>
<li><ol start="2">
<li>将请求回来的数据传递给控制器</li>
</ol>
</li>
<li><ol start="3">
<li>控制器的tableView完成数据的显示</li>
</ol>
</li>
</ul>
</blockquote>
<h4 id="3-1AFN请求数据"><a href="#3-1AFN请求数据" class="headerlink" title="3.1AFN请求数据"></a>3.1AFN请求数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AFHTTPRequestOperationManager *mgr &#x3D; [AFHTTPRequestOperationManager manager];</span><br><span class="line">[mgr GET:@&quot;https:&#x2F;&#x2F;api.douban.com&#x2F;v2&#x2F;book&#x2F;search&quot; parameters:@&#123;@&quot;q&quot;:@&quot;美女&quot;&#125; success:^(AFHTTPRequestOperation * _Nonnull operation, NSDictionary * _Nonnull responseObject) &#123;</span><br><span class="line">    NSLog(@&quot;发送成功&quot;);</span><br><span class="line">    NSArray *dictArray &#x3D; responseObject[@&quot;books&quot;];</span><br><span class="line">    [subscriber sendNext:dictArray];</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-2请求回来的数据传给控制器"><a href="#3-2请求回来的数据传给控制器" class="headerlink" title="3.2请求回来的数据传给控制器"></a>3.2请求回来的数据传给控制器</h4><p>在MVC中，通常会将请求回来的数据<code>responseObject</code>进行初步的处理，放到<code>model</code>模型中，然后<code>tableView</code>的数据源也来自于model，最终完成<code>tableView</code>的绘制和展示。</p>
<p>这里我们通过MVVM的方式，将网络请求的业务逻辑放到VM中处理。在V中实现<code>tableView</code>的数据源方法。</p>
<p>至于事件的处理就交给RAC来解决。RAC中有一个类<code>RACCommond</code>，来处理事件。</p>
<h4 id="3-3具体代码"><a href="#3-3具体代码" class="headerlink" title="3.3具体代码"></a>3.3具体代码</h4><p>处理的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;通过RACCommand获取数据</span><br><span class="line">- (void)getData &#123;</span><br><span class="line">    self.requestCommand &#x3D; [[RACCommand alloc]initWithSignalBlock:^RACSignal *(id input) &#123;</span><br><span class="line">        RACSignal *signal &#x3D; [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">            </span><br><span class="line">        AFHTTPRequestOperationManager *mgr &#x3D; [AFHTTPRequestOperationManager manager];</span><br><span class="line">        [mgr GET:@&quot;https:&#x2F;&#x2F;api.douban.com&#x2F;v2&#x2F;book&#x2F;search&quot; parameters:@&#123;@&quot;q&quot;:@&quot;美女&quot;&#125; success:^(AFHTTPRequestOperation * _Nonnull operation, NSDictionary * _Nonnull responseObject) &#123;</span><br><span class="line">            NSLog(@&quot;发送成功&quot;);</span><br><span class="line">            NSArray *dictArray &#x3D; responseObject[@&quot;books&quot;];</span><br><span class="line">            [subscriber sendNext:dictArray];</span><br><span class="line"></span><br><span class="line">            &#125; failure:^(AFHTTPRequestOperation * _Nonnull operation, NSError * _Nonnull error) &#123;</span><br><span class="line">                NSLog(@&quot;发送失败&quot;);</span><br><span class="line">            &#125;];</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;];</span><br><span class="line">        return signal;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;控制器接受传回来的数据</span><br><span class="line">- (void)getDataFromRequestVM &#123;</span><br><span class="line">    RACSignal *signal &#x3D; [self.requestVM.requestCommand execute:nil];</span><br><span class="line">    </span><br><span class="line">    [signal subscribeNext:^(id x) &#123;</span><br><span class="line">        self.dataArray &#x3D; x;</span><br><span class="line">        [self.tableView reloadData];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-注意："><a href="#4-注意：" class="headerlink" title="4.注意："></a>4.注意：</h3><p>为了避免外部修改，可以使用readOnly<br>以上操作可以分步处理，也可以通过RACCommand的类来处理。</p>
<h3 id="5-github地址"><a href="#5-github地址" class="headerlink" title="5.github地址"></a>5.github地址</h3><p><a href="https://github.com/walkertop/RAC-MVVM-" target="_blank" rel="noopener">demo下载地址</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://betteris.top/RAC-MVVM%E5%B0%81%E8%A3%85%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/" data-id="ck55j78dw0002akx95fb29s7r" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RAC-MVVM/" rel="tag">RAC MVVM</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-RAC之常用方法汇总" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/RAC%E4%B9%8B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/" class="article-date">
  <time datetime="2016-03-21T04:06:10.000Z" itemprop="datePublished">2016-03-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/RAC%E4%B9%8B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/">RAC之常用方法汇总</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、iOS内部对不同事件的处理"><a href="#一、iOS内部对不同事件的处理" class="headerlink" title="一、iOS内部对不同事件的处理"></a>一、iOS内部对不同事件的处理</h1><p>iOS中对不同事件作出响应时，会用不同的方式来处理这些业务逻辑。<br>比如按钮的点击使用action，ScrollView滚动使用delegate，属性值改变使用KVO，通知等系统提供的方式。<br>虽然说是对事件做出相应，但iOS内部需要用不同的方法，时常用起来非常的繁琐。其实这些事件，都可以通过RAC处理。</p>
<h1 id="二、RAC的核心介绍"><a href="#二、RAC的核心介绍" class="headerlink" title="二、RAC的核心介绍"></a>二、RAC的核心介绍</h1><p>RAC内部的核心类是<code>RACSiganl</code>。<br>RACSiganl:信号类,一般表示将来有数据传递，只要有数据改变，信号内部接收到数据，就会马上发出数据。</p>
<p><code>ReactiveCocoa</code>为事件提供了很多处理方法，处理起来非常简单，而且代码放在一起，就不需要跳到对应的方法里。非常便于管理，也很符合我们开发中<code>高聚合，低耦合</code>的思想。</p>
<p>在介绍RAC底层时，我们已经对RAC的实现原理做了说明，本文会介绍RAC对不同事件的各种处理方式。</p>
<h1 id="三、简单介绍不同的方法"><a href="#三、简单介绍不同的方法" class="headerlink" title="三、简单介绍不同的方法"></a>三、简单介绍不同的方法</h1><h2 id="ReactiveCocoa开发中常见用法"><a href="#ReactiveCocoa开发中常见用法" class="headerlink" title="ReactiveCocoa开发中常见用法"></a>ReactiveCocoa开发中常见用法</h2><h3 id="3-1-代替代理"><a href="#3-1-代替代理" class="headerlink" title="3.1 代替代理."></a>3.1 代替代理.</h3><p><code>rac_signalForSelector：</code>用于替代代理。</p>
<h3 id="3-2代替KVO"><a href="#3-2代替KVO" class="headerlink" title="3.2代替KVO :"></a>3.2代替KVO :</h3><p><code>rac_valuesAndChangesForKeyPath：</code>用于监听某个对象的属性改变。</p>
<h3 id="3-3-监听事件"><a href="#3-3-监听事件" class="headerlink" title="3.3 监听事件:"></a>3.3 监听事件:</h3><p><code>rac_signalForControlEvents：</code>用于监听某个事件。</p>
<h3 id="3-4-代替通知"><a href="#3-4-代替通知" class="headerlink" title="3.4 代替通知:"></a>3.4 代替通知:</h3><p><code>rac_addObserverForName:</code>用于监听某个通知。</p>
<h3 id="3-5-监听文本框文字改变"><a href="#3-5-监听文本框文字改变" class="headerlink" title="3.5 监听文本框文字改变:"></a>3.5 监听文本框文字改变:</h3><p><code>rac_textSignal:</code>只要文本框发出改变就会发出这个信号。</p>
<h3 id="3-6-处理当界面有多次请求时，需要都获取到数据时，才能展示界面"><a href="#3-6-处理当界面有多次请求时，需要都获取到数据时，才能展示界面" class="headerlink" title="3.6 处理当界面有多次请求时，需要都获取到数据时，才能展示界面"></a>3.6 处理当界面有多次请求时，需要都获取到数据时，才能展示界面</h3><p><code>rac_liftSelector:withSignalsFromArray:Signals:</code>当传入的Signals(信号数组)，每一个signal都至少sendNext过一次，就会去触发第一个selector参数的方法。<br>使用注意：几个信号，参数一的方法就几个参数，每个参数对应信号发出的数据。</p>
<h2 id="四、代码演示"><a href="#四、代码演示" class="headerlink" title="四、代码演示"></a>四、代码演示</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;&#x2F; 1.代替代理</span><br><span class="line">    &#x2F;&#x2F; 需求：自定义redView,监听红色view中按钮点击</span><br><span class="line">    &#x2F;&#x2F; 之前都是需要通过代理监听，给红色View添加一个代理属性，点击按钮的时候，通知代理做事情</span><br><span class="line">    &#x2F;&#x2F; rac_signalForSelector:把调用某个对象的方法的信息转换成信号，就要调用这个方法，就会发送信号。</span><br><span class="line">    &#x2F;&#x2F; 这里表示只要redV调用btnClick:,就会发出信号，订阅就好了。</span><br><span class="line">    [[redV rac_signalForSelector:@selector(btnClick:)] subscribeNext:^(id x) &#123;</span><br><span class="line">        NSLog(@&quot;点击红色按钮&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 2.KVO</span><br><span class="line">    &#x2F;&#x2F; 把监听redV的center属性改变转换成信号，只要值改变就会发送信号</span><br><span class="line">    &#x2F;&#x2F; observer:可以传入nil</span><br><span class="line">    [[redV rac_valuesAndChangesForKeyPath:@&quot;center&quot; options:NSKeyValueObservingOptionNew observer:nil] subscribeNext:^(id x) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,x);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 3.监听事件</span><br><span class="line">    &#x2F;&#x2F; 把按钮点击事件转换为信号，点击按钮，就会发送信号</span><br><span class="line">    [[self.btn rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(id x) &#123;</span><br><span class="line">       NSLog(@&quot;按钮被点击了&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 4.代替通知</span><br><span class="line">    &#x2F;&#x2F; 把监听到的通知转换信号</span><br><span class="line">    [[[NSNotificationCenter defaultCenter] rac_addObserverForName:UIKeyboardWillShowNotification object:nil] subscribeNext:^(id x) &#123;</span><br><span class="line">        NSLog(@&quot;键盘弹出&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 5.监听文本框的文字改变</span><br><span class="line">   [_textField.rac_textSignal subscribeNext:^(id x) &#123;</span><br><span class="line">       NSLog(@&quot;文字改变了%@&quot;,x);</span><br><span class="line">   &#125;];</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 6.处理多个请求，都返回结果的时候，统一做处理.</span><br><span class="line">    RACSignal *request1 &#x3D; [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        &#x2F;&#x2F; 发送请求1</span><br><span class="line">        [subscriber sendNext:@&quot;发送请求1&quot;];</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    RACSignal *request2 &#x3D; [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        &#x2F;&#x2F; 发送请求2</span><br><span class="line">        [subscriber sendNext:@&quot;发送请求2&quot;];</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 使用注意：几个信号，参数一的方法就几个参数，每个参数对应信号发出的数据。</span><br><span class="line">    [self rac_liftSelector:@selector(updateUIWithR1:r2:) withSignalsFromArray:@[request1,request2]];</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 更新UI（该方法有要求，有多少个信号就要求有多少个参数，参数的内容就是发送的数据。）</span><br><span class="line">- (void)updateUIWithR1:(id)data r2:(id)data1</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;更新UI%@,%@&quot;,data,data1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="文末："><a href="#文末：" class="headerlink" title="文末："></a>文末：</h1><p>这里只是对RAC常用方法合集的简单描述和基础使用的介绍，至于RAC信号的原理，可以参考作者的<a href="http://betteris.top/2016/03/17/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8ReactiveCocoa-RAC-%E4%B9%8B%E4%BF%A1%E5%8F%B7%E7%B1%BB%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">《史上最全RAC之信号类源码解析》</a>。<br>至于RAC的bind(绑定)，map（映射），concat（组合）等高级用法，可参考作者的其它文章。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://betteris.top/RAC%E4%B9%8B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/" data-id="ck55j78e5000bakx99vf47r83" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RAC/" rel="tag">RAC</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-RAC之masonry源码深度解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/RAC%E4%B9%8Bmasonry%E6%BA%90%E7%A0%81%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/" class="article-date">
  <time datetime="2016-03-19T03:52:58.000Z" itemprop="datePublished">2016-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/RAC%E4%B9%8Bmasonry%E6%BA%90%E7%A0%81%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/">RAC之masonry源码深度解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>写在前面：<br>本文不是讲解masonry的基础使用，而是希望借着masonry的源码解析给大家渗透链式编程的思想和展示其具体实现。<br>现在RAC（ReactiveCocoa）很火，借着这个成熟的案例让大家窥其一斑，作者在此抛砖引用，供大家交流参考。</p>
<h1 id="一、NSLayoutConstraint约束"><a href="#一、NSLayoutConstraint约束" class="headerlink" title="一、NSLayoutConstraint约束"></a><strong>一、NSLayoutConstraint约束</strong></h1><p>实际iOS用<code>NSLayoutConstraint</code>对控件进行约束。比如：想要让子控件的顶部距离父控件顶部10pt，添加约束的实际条件就是满足<code>subView.top = superView.top * 1 + 10</code>这个公式就可以了。<br><code>NSLayoutConstraint</code>的实际就是对该公式的代码解释，代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    NSLayoutConstraint *topConstraint &#x3D; [NSLayoutConstraint constraintWithItem:subView</span><br><span class="line">                                 attribute:NSLayoutAttributeTop</span><br><span class="line">                                 relatedBy:NSLayoutRelationEqual</span><br><span class="line">                                    toItem:self.view</span><br><span class="line">                                 attribute:NSLayoutAttributeTop</span><br><span class="line">                                multiplier:1.0</span><br><span class="line">                                                                   constant:padding.top];</span><br><span class="line">    [self.view addConstraints:topConstraint];</span><br></pre></td></tr></table></figure>

<p>但我们需要对控件的top,bottom,left,right进行约束就特别麻烦。在OC中有一个库<code>Masonry</code>对<code>NSLayoutConstraint</code>进行了封装，<strong>****</strong>（<strong><strong>Swift</strong></strong>中使用<strong><strong>SnapKit</strong></strong>，<strong><strong>SnapKit</strong></strong>其实就是<strong><strong>Masonry</strong></strong>的<strong><strong>Swift</strong></strong>版本，实现思路大体一致。）<strong>****</strong></p>
<h1 id="二：masonry介绍"><a href="#二：masonry介绍" class="headerlink" title="二：masonry介绍"></a>二：masonry介绍</h1><p>masonry是iOS布局控件的轻量级框架。其原理是通过链式调用的方式对<code>NSLayoutConstraint</code>进行封装，简化了控件的约束方式。</p>
<p>抓住两头：<br>其实massory最终还是利用苹果官方提供的<code>NSLayoutConstraint</code>，只是利用链式编程的方式进一步封装。</p>
<blockquote>
<p>接下来思考两个问题</p>
<ol>
<li>怎么通过封装？</li>
<li>链式编程来实现约束的添加的？</li>
</ol>
</blockquote>
<p>接下来我们就对masonry的封装做进一步解释。</p>
<h2 id="1-masonry添加约束的代码实现"><a href="#1-masonry添加约束的代码实现" class="headerlink" title="1.masonry添加约束的代码实现"></a>1.masonry添加约束的代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    UIView *subView &#x3D; [[UIView alloc]init];</span><br><span class="line">    subView.backgroundColor &#x3D; [UIColor purpleColor];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;先添加控制，后设置约束，不然找不到约束的依赖，会报错。</span><br><span class="line">    [self.view addSubview:subView];</span><br><span class="line">    [subView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.left.top.equalTo(@20);</span><br><span class="line">        make.right.bottom.equalTo(@-10);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-masonry方法执行步骤解析："><a href="#2-masonry方法执行步骤解析：" class="headerlink" title="2.masonry方法执行步骤解析："></a>2.masonry方法执行步骤解析：</h2><blockquote>
<ul>
<li>子控件调用<code>mas_makeConstraints</code>方法，<code>mas_makeConstraints</code>方法有个block参数（返回值为void,参数为<code>MASContraintMaker</code>的实例对象make）；</li>
<li>block作为方法的参数就是隐式调用（block并没有真正调用，需要在方法内部，block()调用一次，才会真正执行block）；</li>
<li>block的有一个MASContraintMaker类的实例make作为参数，让make去添加约束；</li>
<li>MASContraintMaker类中有个可变数组的属性，用于保存约束；</li>
<li>执行<code>mas_makeConstraints</code>传入进行的block；</li>
<li>遍历数组中的约束，完成约束的安装；</li>
</ul>
</blockquote>
<hr>
<p>以上只是文字描述了执行的大致步骤，具体的代码实现是怎么样的呢？<br>我们接下里通过三个问题来展开。</p>
<h2 id="3-疑问"><a href="#3-疑问" class="headerlink" title="3.疑问"></a>3.疑问</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 1. make的点语法代表什么意思？</span><br><span class="line">&gt; 2. 为什么可以连续用点语法？</span><br><span class="line">&gt; 3. 具体代码解析是什么样的？</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="问题一：make的点语法代表什么意思？"><a href="#问题一：make的点语法代表什么意思？" class="headerlink" title="问题一：make的点语法代表什么意思？"></a>问题一：make的点语法代表什么意思？</h3><p><code>make.left.top.equalTo(@20);</code></p>
<p>实质就是<code>MASContraintMaker</code>类的实例对象make调用了属性的getterter方法。<br>扒开源码我们会看到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface MASConstraintMaker : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong, readonly) MASConstraint *left;</span><br><span class="line">@property (nonatomic, strong, readonly) MASConstraint *top;</span><br><span class="line">&#x2F;&#x2F;省略了bottom,right，baseline等属性。</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;getter方法，返回的是MASConstraint对象，getter方法调用 addConstraintWithLayoutAttribute:</span><br><span class="line">- (MASConstraint *)left &#123;</span><br><span class="line">    return [self addConstraintWithLayoutAttribute:NSLayoutAttributeLeft];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;返回的是MASConstraint对象，接着调用constraint: addConstraintWithLayoutAttribute:方法</span><br><span class="line">- (MASConstraint *)addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute &#123;</span><br><span class="line">    return [self constraint:nil addConstraintWithLayoutAttribute:layoutAttribute];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (MASConstraint *)constraint:(MASConstraint *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute &#123;</span><br><span class="line">    MASViewAttribute *viewAttribute &#x3D; [[MASViewAttribute alloc] initWithView:self.view layoutAttribute:layoutAttribute];</span><br><span class="line">    MASViewConstraint *newConstraint &#x3D; [[MASViewConstraint alloc] initWithFirstViewAttribute:viewAttribute];</span><br><span class="line">    if ([constraint isKindOfClass:MASViewConstraint.class]) &#123;</span><br><span class="line">        &#x2F;&#x2F;replace with composite constraint</span><br><span class="line">        NSArray *children &#x3D; @[constraint, newConstraint];</span><br><span class="line">        MASCompositeConstraint *compositeConstraint &#x3D; [[MASCompositeConstraint alloc] initWithChildren:children];</span><br><span class="line">        compositeConstraint.delegate &#x3D; self;</span><br><span class="line">        [self constraint:constraint shouldBeReplacedWithConstraint:compositeConstraint];</span><br><span class="line">        return compositeConstraint;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!constraint) &#123;</span><br><span class="line">        newConstraint.delegate &#x3D; self;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;</span><br><span class="line">        [self.constraints addObject:newConstraint];</span><br><span class="line">    &#125;</span><br><span class="line">    return newConstraint;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="问题二：为什么可以连续用点语法？"><a href="#问题二：为什么可以连续用点语法？" class="headerlink" title="问题二：为什么可以连续用点语法？"></a>问题二：为什么可以连续用点语法？</h3><blockquote>
<p><strong>链式编程的核心：</strong><br>每个点语法实际调用的getter方法，getter方法的返回值为实例对象本身，然后继续调用getter方法，就成为链式了。<br>结合代码进行具体解释：<code>make.left.top.equalTo(@10);</code><br>我们对其分开解释：点语法返回的时一个新的约束newConstraint。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#96;make.left.top.equalTo(@10);&#96;</span><br><span class="line">&#x2F;&#x2F;分开写就为</span><br><span class="line">newConstraint1 &#x3D; make.left;</span><br><span class="line">newConstraint2 &#x3D; newConstraint1.top;</span><br><span class="line">newConstraint2.equalTo(@10);</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (MASConstraint * (^)(id))equalTo &#123;</span><br><span class="line">    return ^id(id attribute) &#123;</span><br><span class="line">        return self.equalToWithRelation(attribute, NSLayoutRelationEqual);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="问题三：整个方法的具体调用步骤是什么样的？"><a href="#问题三：整个方法的具体调用步骤是什么样的？" class="headerlink" title="问题三：整个方法的具体调用步骤是什么样的？"></a>问题三：整个方法的具体调用步骤是什么样的？</h3><p>首先解释下<code>MASConstraintMaker</code>类：</p>
<blockquote>
<p><code>MASConstraintMaker</code>类就是一个工厂类，负责创建<code>MASConstraint</code>类型的对象（依赖于<code>MASConstraint</code>接口，而不依赖于具体实现）</p>
</blockquote>
<hr>
<blockquote>
<p><strong>粗略步骤：</strong></p>
<ol>
<li>UIView的类调用<code>mas_makeConstraints</code>方法</li>
<li><code>mas_makeConstraints</code>有个block参数，会做隐式回调</li>
<li>获得约束数组，通过install安装约束。</li>
</ol>
</blockquote>
<h4 id="1-mas-makeConstraints方法解析"><a href="#1-mas-makeConstraints方法解析" class="headerlink" title="1.mas_makeConstraints方法解析"></a>1.<code>mas_makeConstraints</code>方法解析</h4><p>用户是UIView调用扩展的<code>UIView+MASAdditions</code>分类的<code>mas_makeConstraints</code>方法来为当前视图添加约束的。<br>mas_makeConstraints方法的返回值是一个数组（NSArray）,数组中所存放的就是当前视图中所添加的所有约束。因为Masonry框架对NSLayoutConstraint封装成了MASViewConstraint，所有此处数组中存储的是MASViewConstraint对象。</p>
<p>接下来来看<code>mas_makeConstraints</code>的参数，<code>mas_makeConstraints</code>测参数是一个类型为<code>void(^)(MASConstraintMaker *)</code>的匿名block（也就是匿名闭包），该闭包的返回值为void, 并且需要一个<code>MASConstraintMaker</code>工厂类的一个对象。该闭包的作用就是可以让<code>mas_makeConstraints</code>方法通过该block给<code>MASConstraintMaker</code>工厂类对象中的<code>MAConstraint</code>属性进行初始化。<br>具体可以参考下面的代码及其注释:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;新建并添加约束</span><br><span class="line">- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *))block &#123;</span><br><span class="line">   &#x2F;&#x2F;关闭自动添加约束，由我们手动添加约束</span><br><span class="line">    self.translatesAutoresizingMaskIntoConstraints &#x3D; NO;</span><br><span class="line">    &#x2F;&#x2F;实例化constraintMaker对象，来操作接下来的约束</span><br><span class="line">    MASConstraintMaker *constraintMaker &#x3D; [[MASConstraintMaker alloc] initWithView:self];</span><br><span class="line">    &#x2F;&#x2F;block作为参数，这里完成隐式调用，完成回调，通过block将constraintMaker对象回调给用户让用户对constraintMaker中的MAConstraint类型的属性进行初始化。换句话说block中所做的事情就是之前用户设置约束是所添加的代码，比如make.top(@10) &#x3D;&#x3D; ( constraintMaker.top &#x3D; 10 )。</span><br><span class="line">    block(constraintMaker);</span><br><span class="line">    &#x2F;&#x2F;添加约束，但会Install的约束数组</span><br><span class="line">    return [constraintMaker install];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-block参数的隐式回调"><a href="#2-block参数的隐式回调" class="headerlink" title="2. block参数的隐式回调"></a>2. block参数的隐式回调</h4><p>返回的值为一个block,block的返回值是MASConstraint类的实例对象，所以最终还是返回的MASConstraint类的实例对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (MASConstraint * (^)(id))equalTo &#123;</span><br><span class="line">    return ^id(id attribute) &#123;</span><br><span class="line">        return self.equalToWithRelation(attribute, NSLayoutRelationEqual);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-约束安装install方法"><a href="#3-约束安装install方法" class="headerlink" title="3.约束安装install方法"></a>3.约束安装install方法</h4><p>实际的过程是：</p>
<blockquote>
<ol>
<li>判断是否有约束，有就遍历约束，调用uninstall清空之前所有的约束</li>
<li>无约束，就遍历数组的约束对象，然后调用install逐个安装</li>
<li>调用系统的方法安装约束</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (NSArray *)install &#123;</span><br><span class="line">  &#x2F;&#x2F;判断是否存在约束，存在就遍历所有约束，然后移除</span><br><span class="line">    if (self.removeExisting) &#123;</span><br><span class="line">        NSArray *installedConstraints &#x3D; [MASViewConstraint installedConstraintsForView:self.view];</span><br><span class="line">        for (MASConstraint *constraint in installedConstraints) &#123;</span><br><span class="line">            [constraint uninstall];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     &#x2F;&#x2F;不存在约束，就复制约束，然后遍历数组中的约束，完成安装。</span><br><span class="line">    NSArray *constraints &#x3D; self.constraints.copy;</span><br><span class="line">    for (MASConstraint *constraint in constraints) &#123;</span><br><span class="line">        constraint.updateExisting &#x3D; self.updateExisting;</span><br><span class="line">        [constraint install];</span><br><span class="line">    &#125;</span><br><span class="line">    [self.constraints removeAllObjects];</span><br><span class="line">    return constraints;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文末："><a href="#文末：" class="headerlink" title="文末："></a>文末：</h2><p>以上是masonry。通过这个也是给大家渗透链式编程的思想。<br>可能很多人对block作为返回值比较难理解，但这是整个链式编程的核心。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://betteris.top/RAC%E4%B9%8Bmasonry%E6%BA%90%E7%A0%81%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/" data-id="ck55j78e10006akx9et319ela" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-史上最全ReactiveCocoa-RAC-之信号类源码解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8ReactiveCocoa-RAC-%E4%B9%8B%E4%BF%A1%E5%8F%B7%E7%B1%BB%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" class="article-date">
  <time datetime="2016-03-17T04:01:13.000Z" itemprop="datePublished">2016-03-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8ReactiveCocoa-RAC-%E4%B9%8B%E4%BF%A1%E5%8F%B7%E7%B1%BB%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">史上最全ReactiveCocoa(RAC)之信号类源码解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>信号signal是RAC的绝对核心，所有的操作都是围绕着信号来处理的。<br>比如：创建信号，订阅信号，发送信号是消息发送的核心步骤。<br>常见的三个信号类为：</p>
<blockquote>
<ul>
<li>RACSignal</li>
<li>RACSubject</li>
<li>RACReplaySubject</li>
</ul>
</blockquote>
<h1 id="一、RACSignal"><a href="#一、RACSignal" class="headerlink" title="一、RACSignal"></a>一、RACSignal</h1><h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1.创建信号</span><br><span class="line">    RACSignal *siganl &#x3D; [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">       &#x2F;&#x2F; 注：block在此仅仅是个参数，未被调用，</span><br><span class="line">       &#x2F;&#x2F;当有订阅者订阅信号时会调用block。</span><br><span class="line">&#x2F;&#x2F; 2.发送信号</span><br><span class="line">        [subscriber sendNext:@1];</span><br><span class="line">        &#x2F;&#x2F; 如果不在发送数据，最好发送信号完成，内部会自动调用[RACDisposable disposable]取消订阅信号。</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;];</span><br><span class="line">&#x2F;&#x2F; 3.订阅信号,才会激活信号.</span><br><span class="line">    [siganl subscribeNext:^(id x) &#123;</span><br><span class="line">        &#x2F;&#x2F; block调用时刻：每当有信号发出数据，就会调用block.</span><br><span class="line">        NSLog(@&quot;接收到数据:%@&quot;,x);</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="使用步骤："><a href="#使用步骤：" class="headerlink" title="使用步骤："></a>使用步骤：</h2><h3 id="1-创建信号"><a href="#1-创建信号" class="headerlink" title="1.创建信号"></a>1.创建信号</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+(RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">内部原理：</span><br><span class="line">* 1.1 方法解析：方法名为createSignal：其返回值类型为RACSignal类的实例变量。参数为一个名字为didSubscribe的block。</span><br><span class="line">* 1.2 方法参数didSubscribe解析：(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe &#123;&#125;的返回值是RACDisposable类型的实例变量，参数为id类型且遵守且遵守RACSubscriber协议的subscriber。</span><br><span class="line">* 1.3 创建信号，首先把didSubscribe这个block保存到信号中，但不会触发。此时didSubscribe仅仅作为方法的参数，并没有被触发，所以信号也仅仅是一个冷信号，block内部不会执行。（具体执行见下文）</span><br><span class="line"></span><br><span class="line">源码解析：</span><br><span class="line">+ (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe &#123;</span><br><span class="line">&#x2F;&#x2F;创建了一个RACDynamicSignal类的信号</span><br><span class="line">RACDynamicSignal *signal &#x3D; [[self alloc] init];</span><br><span class="line">&#x2F;&#x2F;将代码块保存到信号里面（但此时仅仅是保存，没有调用）</span><br><span class="line">signal-&gt;_didSubscribe &#x3D; [didSubscribe copy];</span><br><span class="line">return [signal setNameWithFormat:@&quot;+createSignal:&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="2-订阅信号"><a href="#2-订阅信号" class="headerlink" title="2.订阅信号"></a>2.订阅信号</h3><blockquote>
<p>（激活信号，冷信号编程热信号）</p>
<ul>
<li>(RACDisposable *)subscribeNext:(void (^ )(id x))nextBlock；</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">* 2.1当信号被订阅，也就是调用signal的subscribeNext:nextBlock，</span><br><span class="line">* 2.2nextBlock内部创建了订阅者subscriber，并且把nextBlock保存到subscriber中。</span><br><span class="line">&#x2F;&#x2F;  RACSignal.h</span><br><span class="line">- (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock &#123;</span><br><span class="line">NSCParameterAssert(nextBlock !&#x3D; NULL);</span><br><span class="line"> &#x2F;&#x2F;内部创建了RACSubscriber（订阅者）类的实例对象o，并且将nextBlock保存到o中，在返回值出执行o,实际也是执行了nextBlock。</span><br><span class="line">RACSubscriber *o &#x3D; [RACSubscriber subscriberWithNext:nextBlock error:NULL completed:NULL];</span><br><span class="line">return [self subscribe:o]; &#x2F;&#x2F;内部执行了nextBlock，具体见下文</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (instancetype)subscriberWithNext:(void (^)(id x))next error:(void (^)(NSError *error))error completed:(void (^)(void))completed &#123;</span><br><span class="line"> RACSubscriber *subscriber &#x3D; [[self alloc] init];</span><br><span class="line">&#x2F;&#x2F;将block保存到subscriber中</span><br><span class="line"> subscriber-&gt;_next &#x3D; [next copy];</span><br><span class="line"> subscriber-&gt;_error &#x3D; [error copy];</span><br><span class="line"> subscriber-&gt;_completed &#x3D; [completed copy];</span><br><span class="line"></span><br><span class="line"> return subscriber;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;执行</span><br><span class="line">- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line"> NSCParameterAssert(subscriber !&#x3D; nil);</span><br><span class="line"></span><br><span class="line"> RACCompoundDisposable *disposable &#x3D; [RACCompoundDisposable compoundDisposable];</span><br><span class="line"> subscriber &#x3D; [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:self disposable:disposable];</span><br><span class="line">&#x2F;&#x2F;判断有无self.didSubscribe,有则执行该self.didSubscribe，意味着将订阅者subscriber发送过去</span><br><span class="line"> if (self.didSubscribe !&#x3D; NULL) &#123;</span><br><span class="line">  RACDisposable *schedulingDisposable &#x3D; [RACScheduler.subscriptionScheduler schedule:^&#123;</span><br><span class="line">   RACDisposable *innerDisposable &#x3D; self.didSubscribe(subscriber);</span><br><span class="line">   [disposable addDisposable:innerDisposable];</span><br><span class="line">  &#125;];</span><br><span class="line"></span><br><span class="line">  [disposable addDisposable:schedulingDisposable];</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> return disposable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-发送信号"><a href="#3-发送信号" class="headerlink" title="3.发送信号"></a>3.发送信号</h3><blockquote>
<p>订阅信号时，将subscriber传递给didSubscribe的参数subscriber</p>
<p>利用[subscriber sendNext:@1]方法发送信号。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;  RACSubscriber.h</span><br><span class="line">&#x2F;&#x2F; These callbacks should only be accessed while synchronized on self.</span><br><span class="line">@property (nonatomic, copy) void (^next)(id value);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;名为next的block是返回值为void，参数为id类型的value，在sendNext:内部，将next复制给nextBlock，执行该方法后，subscribeNext:的block参数才会被调用。</span><br><span class="line"></span><br><span class="line">- (void)sendNext:(id)value &#123;</span><br><span class="line"> @synchronized (self) &#123;</span><br><span class="line">  void (^nextBlock)(id) &#x3D; [self.next copy];</span><br><span class="line">  if (nextBlock &#x3D;&#x3D; nil) return;</span><br><span class="line">  &#x2F;&#x2F;执行nextBlock，发送value</span><br><span class="line">  nextBlock(value);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="RACSignal原理流程图："><a href="#RACSignal原理流程图：" class="headerlink" title="RACSignal原理流程图："></a>RACSignal原理流程图：</h2><p><img src="http://upload-images.jianshu.io/upload_images/1467716-d6ea285e8b921f99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RACSignal实现原理图.png"></p>
<hr>
<h2 id="RACSignal总结："><a href="#RACSignal总结：" class="headerlink" title="RACSignal总结："></a>RACSignal总结：</h2><p>三步骤（先创建信号，然后订阅信号，最后执行didSubscribe内部的方法）顺序是不能变的。</p>
<blockquote>
<p>RACSignal底层实现：</p>
</blockquote>
<pre><code>* 1.创建信号，首先把didSubscribe保存到信号中，还不会触发。
* 2.当信号被订阅，也就是调用signal的subscribeNext:nextBlock
  2.1 subscribeNext内部会创建订阅者subscriber，并且把nextBlock保存到subscriber中。
   2.2 subscribeNext内部会调用siganl的didSubscribe
* 3.siganl的didSubscribe中调用[subscriber sendNext:@1];
* 3.1 sendNext底层其实就是执行subscriber的nextBlock</code></pre><hr>
<h1 id="二、RACSubject"><a href="#二、RACSubject" class="headerlink" title="二、RACSubject"></a>二、RACSubject</h1><blockquote>
<p>RACSubject:信号提供者，自己可以充当信号，又能发送信号。</p>
</blockquote>
<p>先来简单回顾下，RACSignal类中发送和订阅信号是两步完成的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;发送信号的为遵守RACSubscribe协议的对象subscriber完成发送</span><br><span class="line">[subscriber sendNext:@1];</span><br><span class="line">&#x2F;&#x2F;订阅信号的为RACSignal的实例对象</span><br><span class="line">[siganl subscribeNext:^(id x) &#123;&#125;；</span><br></pre></td></tr></table></figure>

<ul>
<li>疑问：有没有办法让一个对象既能发送也可以发送消息呢？</li>
</ul>
<p>其实很简单，只要让具有RACSignal对象遵守RACSubscribe协议，就既能发送，又能订阅信号了。<br>这个类就是RACSubject。虽然和RACSignal一样都具有订阅和发送信号的能力，但其内部原理不同。<br>下文是对RACSubject类进行剖析。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><blockquote>
<p>调用顺序不变，但是可以创建多个订阅者，并发送信号；</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;&#x2F; 1.创建信号</span><br><span class="line">    RACSubject *subject &#x3D; [RACSubject subject];   </span><br><span class="line">&#x2F;&#x2F; 2.订阅信号（这里可以创建多个订阅者）</span><br><span class="line">    [subject subscribeNext:^(id x) &#123;</span><br><span class="line">        &#x2F;&#x2F; block调用时刻：当信号发出新值，就会调用.</span><br><span class="line">        NSLog(@&quot;第一个订阅者%@&quot;,x);</span><br><span class="line">    &#125;];</span><br><span class="line">    [subject subscribeNext:^(id x) &#123;</span><br><span class="line">        &#x2F;&#x2F; block调用时刻：当信号发出新值，就会调用.</span><br><span class="line">        NSLog(@&quot;第二个订阅者%@&quot;,x);</span><br><span class="line">    &#125;];</span><br><span class="line">     [subject subscribeNext:^(id x) &#123;</span><br><span class="line">        &#x2F;&#x2F; block调用时刻：当信号发出新值，就会调用.</span><br><span class="line">        NSLog(@&quot;第三个订阅者%@&quot;,x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#x2F;&#x2F; 3.发送信号</span><br><span class="line">    [subject sendNext:@&quot;1&quot;];</span><br></pre></td></tr></table></figure>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="1-创建信号-1"><a href="#1-创建信号-1" class="headerlink" title="1.创建信号"></a>1.创建信号</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;  RACSubject.m</span><br><span class="line">+ (instancetype)subject &#123;</span><br><span class="line"> return [[self alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)init &#123;</span><br><span class="line"> self &#x3D; [super init];</span><br><span class="line"> if (self &#x3D;&#x3D; nil) return nil;</span><br><span class="line"> </span><br><span class="line"> _disposable &#x3D; [RACCompoundDisposable compoundDisposable];</span><br><span class="line"> </span><br><span class="line"> _subscribers &#x3D; [[NSMutableArray alloc] initWithCapacity:1];</span><br><span class="line"> </span><br><span class="line"> return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-订阅信号-1"><a href="#2-订阅信号-1" class="headerlink" title="2.订阅信号"></a>2.订阅信号</h3><blockquote>
<p>不同类型的信号，创建订阅者的方式不同，RACSignal订阅信号时，调用了形影的block。</p>
<p>而RACSubject订阅信号的实质就是将内部创建的订阅者保存在订阅者数组self.subscribers中，仅此而已。订阅者对象有一个名为nextBlock的block参数。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock &#123;</span><br><span class="line"> NSCParameterAssert(nextBlock !&#x3D; NULL);</span><br><span class="line"> </span><br><span class="line"> RACSubscriber *o &#x3D; [RACSubscriber subscriberWithNext:nextBlock error:NULL completed:NULL];</span><br><span class="line"> return [self subscribe:o];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line"> NSCParameterAssert(subscriber !&#x3D; nil);</span><br><span class="line"></span><br><span class="line"> RACCompoundDisposable *disposable &#x3D; [RACCompoundDisposable compoundDisposable];</span><br><span class="line"> subscriber &#x3D; [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:self disposable:disposable];</span><br><span class="line"></span><br><span class="line"> NSMutableArray *subscribers &#x3D; self.subscribers;</span><br><span class="line"> @synchronized (subscribers) &#123;</span><br><span class="line"> &#x2F;&#x2F;将订阅者保存在订阅者数组中</span><br><span class="line">  [subscribers addObject:subscriber];</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">  @synchronized (subscribers) &#123;</span><br><span class="line">   &#x2F;&#x2F; Since newer subscribers are generally shorter-lived, search</span><br><span class="line">   &#x2F;&#x2F; starting from the end of the list.</span><br><span class="line">   NSUInteger index &#x3D; [subscribers indexOfObjectWithOptions:NSEnumerationReverse passingTest:^ BOOL (id&lt;RACSubscriber&gt; obj, NSUInteger index, BOOL *stop) &#123;</span><br><span class="line">    return obj &#x3D;&#x3D; subscriber;</span><br><span class="line">   &#125;];</span><br><span class="line"></span><br><span class="line">   if (index !&#x3D; NSNotFound) [subscribers removeObjectAtIndex:index];</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-发送信号-1"><a href="#3-发送信号-1" class="headerlink" title="3.发送信号"></a>3.发送信号</h3><blockquote>
<p>底层实现是：</p>
</blockquote>
<ol>
<li>先遍历订阅者数组中的订阅者;</li>
<li>后执行订阅者中的nextBlock;</li>
<li>最后让订阅者发送信号。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;  RACSubject.m</span><br><span class="line"></span><br><span class="line">- (void)sendNext:(id)value &#123;</span><br><span class="line">&#x2F;&#x2F;顺序A：遍历保存在数组中的订阅者对象</span><br><span class="line"> [self enumerateSubscribersUsingBlock:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">&#x2F;&#x2F;顺序E：调用订阅者，执行sendNext:方法</span><br><span class="line">  [subscriber sendNext:value];</span><br><span class="line"> &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;顺序B:遍历subscribers数组中的订阅者对象，执行block。</span><br><span class="line">- (void)enumerateSubscribersUsingBlock:(void (^)(id&lt;RACSubscriber&gt; subscriber))block &#123;</span><br><span class="line"> NSArray *subscribers;</span><br><span class="line"> @synchronized (self.subscribers) &#123;</span><br><span class="line">  subscribers &#x3D; [self.subscribers copy];</span><br><span class="line"> &#125;</span><br><span class="line">&#x2F;&#x2F;顺序C:遍历数组，取出subscriber的block，并且执行。</span><br><span class="line"> for (id&lt;RACSubscriber&gt; subscriber in subscribers) &#123;</span><br><span class="line">&#x2F;&#x2F;顺序D,执行block</span><br><span class="line">  block(subscriber);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="RACSubject原理流程图："><a href="#RACSubject原理流程图：" class="headerlink" title="RACSubject原理流程图："></a>RACSubject原理流程图：</h2><p><img src="http://upload-images.jianshu.io/upload_images/1467716-f2b4f5f91210d0ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RACSubject原理图 .png"></p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RACSubscriber:表示订阅者的意思，用于发送信号，这是一个协议，不是一个类，只要遵守这个协议，并且实现方法才能成为订阅者。通过create创建的信号，都有一个订阅者，帮助他发送数据。</span><br><span class="line"></span><br><span class="line">RACDisposable:用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>RACSubject:底层实现和RACSignal不一样。</p>
</blockquote>
<ul>
<li><p>1.调用subscribeNext订阅信号，只是把订阅者保存起来，并且订阅者的nextBlock已经赋值了。</p>
</li>
<li><p>2.调用sendNext发送信号，遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。</p>
</li>
<li><p>3.由于本质是将订阅者保存到数组中，所以可以有多个订阅者订阅信息。</p>
</li>
</ul>
<p>使用场景:不想监听某个信号时，可以通过它主动取消订阅信号。<br>RACSubject:信号提供者，自己可以充当信号，又能发送信号。</p>
<p>使用场景:通常用来代替代理，有了它，就不必要定义代理了。</p>
<blockquote>
<p><strong>缺点：</strong><br>还是必须先订阅，后发送信息。订阅信号就是创建订阅者的过程，如果不先订阅，数组中就没有订阅者对象，那就通过订阅者发送消息。</p>
</blockquote>
<hr>
<h1 id="三、RACReplaySubject"><a href="#三、RACReplaySubject" class="headerlink" title="三、RACReplaySubject"></a>三、RACReplaySubject</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>上文中提到了，RACSubject要求先订阅，后发送信号。<br><strong>##**</strong>代码实现：**</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1.创建信号</span><br><span class="line">    RACReplaySubject *subject &#x3D; [RACReplaySubject subject];</span><br><span class="line">&#x2F;&#x2F; 2.订阅信号</span><br><span class="line">    [subject subscribeNext:^(id x) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,x);</span><br><span class="line">    &#125;];</span><br><span class="line">    &#x2F;&#x2F; 遍历所有的值,拿到当前订阅者去发送数据</span><br><span class="line">&#x2F;&#x2F; 3.发送信号</span><br><span class="line">    [subject sendNext:@1];</span><br><span class="line">    &#x2F;&#x2F; RACReplaySubject发送数据:</span><br><span class="line">    &#x2F;&#x2F; 1.保存值</span><br><span class="line">    &#x2F;&#x2F; 2.遍历所有的订阅者,发送数据</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; RACReplaySubject:可以先发送信号,在订阅信号</span><br></pre></td></tr></table></figure>
<h2 id="使用步骤：-1"><a href="#使用步骤：-1" class="headerlink" title="使用步骤："></a>使用步骤：</h2><h3 id="1-创建信号-2"><a href="#1-创建信号-2" class="headerlink" title="1.创建信号"></a>1.创建信号</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;  RACReplaySubject.m</span><br><span class="line"></span><br><span class="line">+ (instancetype)subject &#123;</span><br><span class="line"> return [[self alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line"> return [self initWithCapacity:RACReplaySubjectUnlimitedCapacity];</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;此时调用的子类RACReplaySubject的初始化方法</span><br><span class="line">- (instancetype)initWithCapacity:(NSUInteger)capacity &#123;</span><br><span class="line"> self &#x3D; [super init];</span><br><span class="line"> if (self &#x3D;&#x3D; nil) return nil;</span><br><span class="line"> </span><br><span class="line"> _capacity &#x3D; capacity;</span><br><span class="line">&#x2F;&#x2F;会用_valuesReceived这个数组保存值value</span><br><span class="line"> _valuesReceived &#x3D; (capacity &#x3D;&#x3D; RACReplaySubjectUnlimitedCapacity ? [NSMutableArray array] : [NSMutableArray arrayWithCapacity:capacity]);</span><br><span class="line"> </span><br><span class="line"> return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-订阅信号-2"><a href="#2-订阅信号-2" class="headerlink" title="2.订阅信号"></a>2.订阅信号</h3><blockquote>
<p>遍历拿到保存在数组中的所有值，然后调用subscriber发送信号。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock &#123;</span><br><span class="line"> NSCParameterAssert(nextBlock !&#x3D; NULL);</span><br><span class="line"> </span><br><span class="line"> RACSubscriber *o &#x3D; [RACSubscriber subscriberWithNext:nextBlock error:NULL completed:NULL];</span><br><span class="line"> return [self subscribe:o];      &#x2F;&#x2F;创建订阅者的方式不同</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;RACReplaySubject类对象执行[self subscribe:o]</span><br><span class="line">- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line"> RACCompoundDisposable *compoundDisposable &#x3D; [RACCompoundDisposable compoundDisposable];</span><br><span class="line"></span><br><span class="line"> RACDisposable *schedulingDisposable &#x3D; [RACScheduler.subscriptionScheduler schedule:^&#123;</span><br><span class="line">  @synchronized (self) &#123;</span><br><span class="line">&#x2F;&#x2F;先遍历self.valuesReceived的所有的值，后让subscriber调用sendNext:发送信号。</span><br><span class="line">   for (id value in self.valuesReceived) &#123;</span><br><span class="line">    if (compoundDisposable.disposed) return;</span><br><span class="line"></span><br><span class="line">    [subscriber sendNext:(value &#x3D;&#x3D; RACTupleNil.tupleNil ? nil : value)];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (compoundDisposable.disposed) return;</span><br><span class="line"></span><br><span class="line">   if (self.hasCompleted) &#123;</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">   &#125; else if (self.hasError) &#123;</span><br><span class="line">    [subscriber sendError:self.error];</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">    RACDisposable *subscriptionDisposable &#x3D; [super subscribe:subscriber];</span><br><span class="line">    [compoundDisposable addDisposable:subscriptionDisposable];</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;];</span><br><span class="line"></span><br><span class="line"> [compoundDisposable addDisposable:schedulingDisposable];</span><br><span class="line"></span><br><span class="line"> return compoundDisposable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-发送信号-2"><a href="#3-发送信号-2" class="headerlink" title="3.发送信号"></a>3.发送信号</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)sendNext:(id)value &#123;</span><br><span class="line"> @synchronized (self) &#123;</span><br><span class="line">&#x2F;&#x2F;重点：发送信号的时候，会先将值value保存到数组中，</span><br><span class="line">  [self.valuesReceived addObject:value ?: RACTupleNil.tupleNil];</span><br><span class="line">&#x2F;&#x2F;调用父类发送（先遍历订阅者，然后发送值value）</span><br><span class="line">  [super sendNext:value];</span><br><span class="line">  </span><br><span class="line">  if (self.capacity !&#x3D; RACReplaySubjectUnlimitedCapacity &amp;&amp; self.valuesReceived.count &gt; self.capacity) &#123;</span><br><span class="line">   [self.valuesReceived removeObjectsInRange:NSMakeRange(0, self.valuesReceived.count - self.capacity)];</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="RACReplaySubject原理图"><a href="#RACReplaySubject原理图" class="headerlink" title="RACReplaySubject原理图"></a>RACReplaySubject原理图</h2><p><img src="http://upload-images.jianshu.io/upload_images/1467716-df43b214a0a047c4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RACReplaySubject原理图.jpg"></p>
<h2 id="RACReplaySubject总结"><a href="#RACReplaySubject总结" class="headerlink" title="RACReplaySubject总结"></a>RACReplaySubject总结</h2><p>RACReplaySubject是RACSubject的子类。</p>
<p>RACReplaySubject使用步骤:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 1.创建信号 [RACSubject subject]，跟RACSiganl不一样，创建信号时没有block。</span><br><span class="line">&#x2F;&#x2F; 2.可以先订阅信号，也可以先发送信号。</span><br><span class="line">  &#x2F;&#x2F; 2.1 订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock</span><br><span class="line">  &#x2F;&#x2F; 2.2 发送信号 sendNe</span><br></pre></td></tr></table></figure>



      
    </div>
    <footer class="article-footer">
      <a data-url="http://betteris.top/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8ReactiveCocoa-RAC-%E4%B9%8B%E4%BF%A1%E5%8F%B7%E7%B1%BB%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" data-id="ck55j78em000vakx92sl0cvf5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RAC/" rel="tag">RAC</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-趣谈iOS运行时之方法调用原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E8%B6%A3%E8%B0%88iOS%E8%BF%90%E8%A1%8C%E6%97%B6%E4%B9%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E5%8E%9F%E7%90%86/" class="article-date">
  <time datetime="2016-01-19T04:13:53.000Z" itemprop="datePublished">2016-01-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E8%B6%A3%E8%B0%88iOS%E8%BF%90%E8%A1%8C%E6%97%B6%E4%B9%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E5%8E%9F%E7%90%86/">趣谈iOS运行时之方法调用原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><p>一个成熟的计算机语言必然有丰富的体系，复杂的容错机制，处理逻辑以及判断逻辑。但这些复杂的逻辑都是围绕一个主线丰富和展开的，所以在学习计算机语言的时候，先掌握核心，然后了解其原理，明白程序语言设计的实质和当时选择这种处理方式的原因是极其必要的，而且也是学习语言的捷径。</p>
<p><strong>所以在学习的过程中，需要把握几个核心</strong></p>
<blockquote>
<p>先专注主线，后丰富周边；<br>先宏观了解，后微观精通;<br>多设身处地思考，理解代码设计的原因;<br>理解代码设计的原理和优化</p>
</blockquote>
<hr>
<p>OC中处理方法的业务逻辑和其他语言不同，OC语言是动态语言（<code>动态绑定</code>，<code>动态加载</code>(dynamatic binding),<code>动态类型</code>）。其中动态加载就涉及到OC的运行时。在OC中，方法是动态实现的，调用方法实际就是在<code>发送消息</code>。<br><strong>试想一下，一个方法的实现必然包含三个部分：</strong></p>
<blockquote>
<p>1.执行方法的对象<br>2.方法名称<br>3.不确定的参数</p>
</blockquote>
<p><code>SEL</code>只是一个方法名称，<code>IMP</code>才是执行方法最终的函数。<code>IMP</code> 是一个函数指针,包含一个<code>接收消息的对象</code> id(self 指针), <code>调用方法的选标</code> <code>SEL</code> (方法名),以及不定个数的<code>参数</code>,并返回一个 id。也就是说 <code>IMP</code> 是消息最终调用的执行代码,是方法真正的实现代码 。</p>
<hr>
<p>提问时间到了：</p>
<blockquote>
<ul>
<li>动态和静态有什么区别？</li>
<li>执行方法是怎么实现的？</li>
<li>OC的方法和C语言的函数原理一样么？</li>
</ul>
</blockquote>
<p>动态和静态有区别的；首先我们从最表层理解，一个方法的实现必然要包含执行者，方法名和不确定的参数和返回值。无论是静态或者动态方法都必须这三个必要元素(<code>动态和静态的区别就在于在何时确定这些必要元素</code>)。<br>方法的执行包含编译和运行两个过程。</p>
<blockquote>
<ul>
<li>静态方法是在编译时已经确定了三个要素，且不能更改。若类型不对，就会直接发出警告。</li>
<li>而OC的动态方法可以直接跳过编译，在运行时才开始添加函数调用，决定执行方法的三个要素。这就是动态方法（至于怎么执行，下面开始讲解）</li>
</ul>
</blockquote>
<p>这三个元素是如何确定的呢？首先我们看一段示例代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dog *aDog &#x3D; [[Dog alloc]init];</span><br><span class="line">[aDog run];</span><br></pre></td></tr></table></figure>
<p>在执行方法时，是怎么确定的呢？<br>此时我们需要注意OC内部方法的实质：OC中，方法实现实质就是发送消息。<br><code>[aDog run];</code>代码的实质就是<code>[ objc_sendMsg]</code>，它会找到执行方法的三个要素，找到就按照规则执行。<br>发送消息是通过 <code>objc_send(id, SEL, ...)</code> 来实现的,它首先会在对象的类对象的 <code>cache</code>，<code>methodlist</code> 以及父类对象的 <code>cache</code>,<code>methodlist</code> 中依次查找 <code>SEL</code> 对应 的 <code>IMP</code>;<br>如果没有找到且实现了动态方法决议机制就会进行决议。</p>
<p>如果没有实现动态方法决议机制或决议失败且实现了消息转发机制就会进入消息转发流程,否则程序 crash。<br>也就是说如果同时提供了<code>动态方法决议</code>和<code>消息转发</code>,那么动态方法决议先于消息转发,只有当动态方法决议依然无法正确决议 <code>selector</code> 的 实现,才会尝试进行消息转发。当然，实际过程不可能那么简单，在开发语言之初，肯定会完善各种复杂场景和做了很多优化，接下来我们一起研究下OC对方法执行和扩展和优化：</p>
<blockquote>
<ul>
<li>第一步：先找方法</li>
<li>第二步：动态方法决议</li>
<li>第三部：消息转发</li>
<li>最后： 报错</li>
</ul>
</blockquote>
<h2 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h2><p>通常,给一个对象发送它不能处理的消息会得到出错提示,然而,<code>Objective-C</code>运行时系统在抛出错误之前, 会给消息接收对象发送一条特别的消息 <code>forwardInvocation</code> 来通该对象,该消息的唯一参数是个 <code>NSInvocation</code> 类型的对象——该对象封装了原始的消息和消息的参数。我们可以实现 <code>forwardInvocation:</code>方法来对不能处理的消息做一些默认的处理,也可以将消息转发给其他对 象来处理,而不抛出错误。</p>
<blockquote>
<ul>
<li>1,首先去该类的方法<code>cache</code>中查找,如果找到了就返回它;</li>
<li>2,如果没有找到,就去该类的方法列表中查找。如果在该类的方法列表中找到了,则将 <code>IMP</code> 返回,并将 它加入 <code>cache</code> 中缓存起来。根据最近使用原则,这个方法再次调用的可能性很大,缓存起来可以节省下次 调用再次查找的开销。</li>
<li>3,如果在该类的方法列表中没找到对应的<code>IMP</code>,在通过该类结构中的<code>super_class</code>指针在其父类结构的方法列表中去查找,直到在某个父类的方法列表中找到对应的<code>IMP</code>,返回它,并加入<code>cache</code>中;</li>
<li>4,如果在自身以及所有父类的方法列表中都没有找到对应的 <code>IMP</code>,则看是不是可以进行动态方法决议(后 面有专文讲述这个话题);</li>
<li>5,如果动态方法决议没能解决问题,进入下面要讲的消息转发流程。便利函数:我们可以通过 <code>NSObject</code> 的一些方法获取运行时信息或动态执行一些消息:</li>
</ul>
</blockquote>
<hr>
<p>class 返回对象的类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isKindOfClass,isMemberOfClass 检查对象是否在指定的类继承体系中;</span><br><span class="line">respondsToSelector 检查对象能否相应指定的消息;</span><br><span class="line">conformsToProtocol 检查对象是否实现了指定协议类的方法;</span><br><span class="line">methodForSelector 返回指定方法实现的地址；</span><br><span class="line">performSelector:withObject 执行 SEL 所指代的方法</span><br></pre></td></tr></table></figure>

<p> OC做为一门面向对象语言，自然具有面向对象的语言特性，如<code>封装</code>、<code>继承</code>、<code>多态</code>。他具有静态语言的特性(如C++)，又有动态语言的效率(动态绑定、动态加载等)。整体来说，确实是一门不错的编程语言。</p>
<hr>
<h2 id="OC的动态语言特性"><a href="#OC的动态语言特性" class="headerlink" title="OC的动态语言特性"></a>OC的动态语言特性</h2><p>现在，让我来想想OC的动态语言特性。OC的动态特性表现为了三个方面：<br><code>动态类型</code>、<code>动态绑定</code>、<code>动态加载</code>。<br>之所以叫做动态，是因为必须到运行时(<code>runtime</code>)才会做一些事情。</p>
<h3 id="（1）动态类型"><a href="#（1）动态类型" class="headerlink" title="（1）动态类型"></a>（1）动态类型</h3><p>动态类型，说简单点就是id类型。动态类型是跟静态类型相对的。像内置的明确的基本类型都属于静态类型(int、NSString等)。静态类型在编译的时候就能被识别出来。所以，若程序发生了类型不对应，编译器就会发出警告。而动态类型就编译器编译的时候是不能被识别的，要等到运行时(<code>runtime</code>)，即程序运行的时候才会根据语境来识别。所以这里面就有两个概念要分清：编译时跟运行时。</p>
<h3 id="（2）动态绑定"><a href="#（2）动态绑定" class="headerlink" title="（2）动态绑定"></a>（2）动态绑定</h3><p>动态绑定(<code>dynamic binding</code>)貌似比较难记忆，但事实上很简单，只需记住关键词<code>@selector/SEL</code>即可。先来看看“函数”，对于其他一些静态语言，比如c++,一般在编译的时候就已经将将要调用的函数的函数签名都告诉编译器了。静态的，不能改变。而在OC中，其实是没有函数的概念的，我们叫“消息机制”，所谓的函数调用就是给对象发送一条消息。这时，动态绑定的特性就来了。OC可以先跳过编译，到运行的时候才动态地添加函数调用，在运行时才决定要调用什么方法，需要传什么参数进去。这就是动态绑定，要实现他就必须用SEL变量绑定一个方法。最终形成的这个<code>SEL</code>变量就代表一个方法的引用。这里要注意一点：<code>SEL</code>并不是C里面的函数指针，虽然很像，但真心不是函数指针。<code>SEL</code>变量只是一个整数，他是该方法的ID。以前的函数调用，是根据函数名，也就是字符串去查找函数体。但现在，我们是根据一个ID整数来查找方法，整数的查找字自然要比字符串的查找快得多！所以，动态绑定的特定不仅方便，而且效率更高。</p>
<h3 id="（3）动态加载"><a href="#（3）动态加载" class="headerlink" title="（3）动态加载"></a>（3）动态加载</h3><p>动态加载就是根据需求动态地加载资源。我对动态加载比较陌生，所以就没什么可总结的啦。等以后慢慢完善。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>技术学习绝不能孤胆英雄独闯天涯，而应在一群人的交流碰撞，享受智慧火花的狂欢。<br>希望我的文章能成为你的盛宴，也渴望你的建议能成为我的大餐。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://betteris.top/%E8%B6%A3%E8%B0%88iOS%E8%BF%90%E8%A1%8C%E6%97%B6%E4%B9%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E5%8E%9F%E7%90%86/" data-id="ck55j78eh000oakx907aebeg2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/runtime/" rel="tag">runtime</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-成员变量和属性的前世今生" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%9E%E6%80%A7%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/" class="article-date">
  <time datetime="2015-10-19T11:13:25.000Z" itemprop="datePublished">2015-10-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%9E%E6%80%A7%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/">成员变量和属性的前世今生</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h1><p>1.简述编译器的变化对@property的影响；<br>2.实际使用中@property和<code>成员变量+ @property + @synthesize 成员变量</code>的区别<br>3.<code>self.XXX</code>,<code>_XXX</code>,<code>self-&gt;XXX</code>的区别；<br>4.<a href="https://github.com/walkertop/--Demo.git" target="_blank" rel="noopener">Demo地址</a></p>
<h3 id="历史由来："><a href="#历史由来：" class="headerlink" title="历史由来："></a>历史由来：</h3><p>接触iOS的人都知道，<code>@property</code>声明的属性默认会生成一个_类型的成员变量，同时也会生成<code>setter/getter</code>方法。<br>但这只是在iOS5之后，苹果推出的一个新机制。看老代码时，经常看到一个大括号里面定义了成员变量，同时用了@property声明，而且还在@implementation中使用<code>@synthesize</code>方法。<br>如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()</span><br><span class="line">&#123;</span><br><span class="line">   &#x2F;&#x2F; 1.声明成员变量</span><br><span class="line">    NSString *myString;  </span><br><span class="line"> &#125;</span><br><span class="line"> &#x2F;&#x2F;2.在用@property</span><br><span class="line">@property(nonatomic, copy) NSString *myString;  </span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line">&#x2F;&#x2F;3.最后在@implementation中用synthesize生成set方法</span><br><span class="line">@synthesize myString;   </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>其实，发生这种状况根本原因是苹果将默认编译器从GCC转换为LLVM(<code>low level virtual machine</code>)，才不再需要为属性声明实例变量了。</p>
<p>在没有更改之前，属性的正常写法需要<code>成员变量+ @property + @synthesize 成员变量</code>三个步骤。<br>如果我们只写<code>成员变量+ @property</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interface GBViewController :UIViewController</span><br><span class="line">&#123;</span><br><span class="line">    NSString *myString;</span><br><span class="line">&#125;</span><br><span class="line">@property (nonatomic, strong) NSString *myString;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><strong>编译时会报警告:</strong></p>
<figure class="highlight plain"><figcaption><span>property 'myString' will use synthesized instance variable '_myString', not existing instance variable 'myString''```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">但更换为LLVM之后，编译器在编译过程中发现没有新的实例变量后，就会生成一个下划线开头的实例变量。因此现在我们不必在声明一个实例变量。（**注意：是不必要，不是不可以**）</span><br><span class="line">当然我们也熟知，&#96;@property&#96;声明的属性不仅仅默认给我们生成一个_类型的成员变量，同时也会生成&#96;setter&#x2F;getter&#96;方法。</span><br><span class="line"></span><br><span class="line">在&#96;.m&#96;文件中，编译器也会自动的生成一个实例变量&#96;_XXX&#96;。那么在.m文件中可以直接的使用&#96;_XXX&#96;实例变量，也可以通过属性&#96;self. XXX&#96;。</span><br><span class="line"></span><br><span class="line">只是我们需要注意这里的&#96;self.XXX&#96;实际是调用&#96;XXX&#96;属性的&#96;setter&#x2F;getter&#96;方法。这与C++中点的使用是有区别的，C++中的点可以直接访问成员变量(也就是实例变量)。</span><br><span class="line"></span><br><span class="line">**例如在OC中有如下代码**</span><br></pre></td></tr></table></figure>
<p>@interface MyViewController :UIViewController<br>{<br>    NSString *name;<br>}<br>@end</p>
<pre><code>在这段代码里面只是声明了一个成员变量，并没有`setter/getter`方法。所以访问成员变量时，可以直接访问`name`，也可以像C++一样用`self-&gt;name`来访问，但绝对不能用`self.name`来访问。

&gt; - **扩展**:很多人觉得OC中的点语法比较奇怪，实际是OC设计人员有意为之。
&gt; - `点表达式(.)`看起来与C语言中的结构体访问以及java语言汇总的对象访问有点类似，如果点表达式出现在等号 `＝` 左边，调用该属性名称的`setter`方法。如果点表达式出现在`＝`右边，调用该属性名称的`getter`方法。
&gt; - OC中`点表达式(.)`其实就是调用对象的`setter`和`getter`方法的一种快捷方式，`self.myString = @&quot;张三&quot;;`实际就是`[self setmyString:@&quot;张三&quot;];`


首先我们要明白，`@synthesize` 生成了`setter/getter`方法。
虽然现在直接使用`@property`时，编译器会自动为你生成以下划线开头的实例变量`_myString`，不需要自己手动再去写实例变量。而且也不在.m文件中通过`@synthesize myString；`生成`setter/getter`方法。但在看老代码的时候，我们依旧可以看到有人使用`成员变量+ @synthesize 成员变量`的形式。

&gt; **那么问题来了：**
&gt; 我们能否认为新编译器LLVM下的`@property ` == 老编译器GCC的 `成员变量+ @property + @synthesize 成员变量`呢？

&gt; 答案是否定的，
&gt; 因为`成员变量+ @property + @synthesize 成员变量`的形式，编译器不会帮我们生成`_成员变量`，因此不会操作`_成员变量`了；
&gt; 同时`@synthesize` 还有一个作用，可以指定与属性对应的实例变量，
&gt; 例如`@synthesize myString = xxx；`
那么`self.myString`其实是操作的实例变量xxx，而非_String了。

在[Demo](https://github.com/walkertop/--Demo.git)中会有非常详细的说明，欢迎下载和start。

## 写在最后

技术学习绝不能孤胆英雄独闯天涯，而应在一群人的交流碰撞，享受智慧火花的狂欢。
希望我的文章能成为你的盛宴，也渴望你的建议能成为我的大餐。

</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://betteris.top/%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%9E%E6%80%A7%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/" data-id="ck55j78ei000pakx9737i73lk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-%E5%B1%9E%E6%80%A7/" rel="tag">成员变量 属性</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-category和extension史上最全攻略" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/category%E5%92%8Cextension%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8%E6%94%BB%E7%95%A5/" class="article-date">
  <time datetime="2015-09-29T04:23:39.000Z" itemprop="datePublished">2015-09-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/category%E5%92%8Cextension%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8%E6%94%BB%E7%95%A5/">category和extension史上最全攻略</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h2><p>在大型项目，企业级开发中多人同时维护同一个类，此时程序员A因为某项需求只想给当前类<code>currentClass</code>添加一个方法<code>newMethod</code>，那该怎么办呢？<br>最简单粗暴的方式是把<code>newMethod</code>添加到<code>currentClass</code>中，然后直接实现该方法就OK了。<br>但考虑到OC是单继承的，子类可以拥有父类的方法和属性。<br>如果把<code>newMethod</code>写到<code>currentClass</code>中，那么<code>currentClass</code>的子类也会拥有<code>newMethod</code>。但真正的需求是只需要<code>currentClass</code>拥有<code>newMethod</code>，而<code>currentClass</code>的子类不会拥有。<br>苹果为了解决这个问题，就引入了分类（Category）的概念。</p>
<h2 id="分类（Category）："><a href="#分类（Category）：" class="headerlink" title="分类（Category）："></a>分类（Category）：</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>分类（Category）是OC中的特有语法，它是表示一个指向分类的结构体的指针。原则上它只能增加方法，不能增加成员（实例）变量。具体原因看源码组成:</p>
<h3 id="Category源码："><a href="#Category源码：" class="headerlink" title="Category源码："></a>Category源码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Category</span><br><span class="line">Category 是表示一个指向分类的结构体的指针，其定义如下：</span><br><span class="line">typedef struct objc_category *Category;</span><br><span class="line">struct objc_category &#123;</span><br><span class="line">  char *category_name                          OBJC2_UNAVAILABLE; &#x2F;&#x2F; 分类名</span><br><span class="line">  char *class_name                             OBJC2_UNAVAILABLE; &#x2F;&#x2F; 分类所属的类名</span><br><span class="line">  struct objc_method_list *instance_methods    OBJC2_UNAVAILABLE; &#x2F;&#x2F; 实例方法列表</span><br><span class="line">  struct objc_method_list *class_methods       OBJC2_UNAVAILABLE; &#x2F;&#x2F; 类方法列表</span><br><span class="line">  struct objc_protocol_list *protocols         OBJC2_UNAVAILABLE; &#x2F;&#x2F; 分类所实现的协议列表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">通过上面我们可以发现，这个结构体主要包含了分类定义的实例方法与类方法，其中instance_methods 列表是 objc_class 中方法列表的一个子集，而class_methods列表是元类方法列表的一个子集。</span><br><span class="line">但这个结构体里面</span><br><span class="line"></span><br><span class="line">根本没有属性列表，</span><br><span class="line">根本没有属性列表，</span><br><span class="line">根本没有属性列表。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：<br>1.分类是用于给原有类添加方法的,因为分类的结构体指针中，没有属性列表，只有方法列表。所以&lt; <strong>原则上讲它只能添加方法, 不能添加属性(成员变量),实际上可以通过其它方式添加属性</strong>&gt; ;<br>2.分类中的可以写@property, 但不会生成<code>setter/getter</code>方法, 也不会生成实现以及私有的成员变量（编译时会报警告）;<br>3.可以在分类中访问原有类中.h中的属性;<br>4.如果分类中有和原有类同名的方法, 会优先调用分类中的方法, 就是说会忽略原有类的方法。所以同名方法调用的优先级为 <code>分类 &gt; 本类 &gt; 父类</code>。因此在开发中尽量不要覆盖原有类;<br>5.如果多个分类中都有和原有类中同名的方法, 那么调用该方法的时候执行谁由编译器决定；编译器会执行最后一个参与编译的分类中的方法。</p>
</blockquote>
<h3 id="分类格式："><a href="#分类格式：" class="headerlink" title="分类格式："></a>分类格式：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface 待扩展的类（分类的名称）</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation 待扩展的名称（分类的名称）</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<h3 id="实际代码如下："><a href="#实际代码如下：" class="headerlink" title="实际代码如下："></a>实际代码如下：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;  Programmer+Category.h文件中</span><br><span class="line">@interface Programmer (Category)</span><br><span class="line"></span><br><span class="line">@property(nonatomic,copy) NSString *nameWithSetterGetter;           &#x2F;&#x2F;设置setter&#x2F;getter方法的属性</span><br><span class="line"></span><br><span class="line">@property(nonatomic,copy) NSString *nameWithoutSetterGetter;        &#x2F;&#x2F;不设置setter&#x2F;getter方法的属性（注意是可以写在这，而且编译只会报警告，运行不报错）</span><br><span class="line"></span><br><span class="line">- (void) programCategoryMethod;                                     &#x2F;&#x2F;分类方法</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  Programmer+Category.m文件中</span><br></pre></td></tr></table></figure>

<p><strong>那么问题来了：</strong></p>
<blockquote>
<p>为什么在分类中声明属性时，运行不会出错呢？<br>既然分类不让添加属性，那为什么我写了@property仍然还以编译通过呢？</p>
</blockquote>
<p> <strong>接下来我们探究下分类不能添加属性的实质原因：</strong></p>
<blockquote>
<p>我们知道在一个类中用@property声明属性，编译器会自动帮我们生成<code>_成员变量</code>和<code>setter/getter</code>，但分类的指针结构体中，根本没有属性列表。所以在分类中用@property声明属性，既无法生成<code>_成员变量</code>也无法生成<code>setter/getter</code>。<br>因此结论是：我们可以用@property声明属性，编译和运行都会通过，只要不使用程序也不会崩溃。但如果调用了<code>_成员变量</code>和<code>setter/getter</code>方法，报错就在所难免了。</p>
</blockquote>
<hr>
<blockquote>
<p><strong>报错原因如下</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;普通声明，无setter&#x2F;getter</span><br><span class="line">&#x2F;&#x2F;    programmer.nameWithoutSetterGetter &#x3D; @&quot;无setter&#x2F;getter&quot;;    &#x2F;&#x2F;调用setter，编译成功，运行报错为：（-[Programmer setNameWithSetterGetter:]: unrecognized selector sent to instance 0x7f9de358fd70&#39;）</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;    NSLog(@&quot;%@&quot;,programmer.nameWithoutSetterGetter);           &#x2F;&#x2F;调用getter，编译成功，运行报错为-[Programmer setNameWithSetterGetter:]: unrecognized selector sent to instance 0x7fe22be11ea0&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;    NSLog(@&quot;%@&quot;,_nameWithoutSetterGetter);        &#x2F;&#x2F;这是调用_成员变量,错误提示为：（Use of undeclared identifier &#39;_nameWithoutSetterGetter&#39;）</span><br></pre></td></tr></table></figure>

<p>那接下来我们继续思考:<br>既然报错的根本原因是使用了系统没有生成的<code>setter/getter</code>方法，可不可以在手动添加<code>setter/getter</code>来避免崩溃，完成调用呢？<br>其实是可以的。由于OC是动态语言，方法真正的实现是通过<code>runtime</code>完成的，虽然系统不给我们生成<code>setter/getter</code>，但我们可以通过<code>runtime</code>手动添加<code>setter/getter</code>方法。那具体怎么实现呢？</p>
<h3 id="代码实现如下"><a href="#代码实现如下" class="headerlink" title="代码实现如下:"></a>代码实现如下:</h3><p>按照这个思路，我们通过运行时手动添加这个方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;objc&#x2F;runtime.h&gt;</span><br><span class="line"></span><br><span class="line">static NSString *nameWithSetterGetterKey &#x3D; @&quot;nameWithSetterGetterKey&quot;;   &#x2F;&#x2F;定义一个key值</span><br><span class="line">@implementation Programmer (Category)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;运行时实现setter方法</span><br><span class="line">- (void)setNameWithSetterGetter:(NSString *)nameWithSetterGetter &#123;</span><br><span class="line">        objc_setAssociatedObject(self, &amp;nameWithSetterGetterKey, nameWithSetterGetter, OBJC_ASSOCIATION_COPY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;运行时实现getter方法</span><br><span class="line">- (NSString *)nameWithSetterGetter &#123;</span><br><span class="line">    return objc_getAssociatedObject(self, &amp;nameWithSetterGetterKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h3 id="实际使用效果"><a href="#实际使用效果" class="headerlink" title="实际使用效果"></a>实际使用效果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;通过runtime实现了setter&#x2F;getter</span><br><span class="line">    programmer.nameWithSetterGetter &#x3D; @&quot;有setter&#x2F;getter&quot;;    &#x2F;&#x2F;调用setter，成功</span><br><span class="line">    NSLog(@&quot;%@&quot;,programmer.nameWithSetterGetter);            &#x2F;&#x2F;调用getter，成功</span><br><span class="line">&#x2F;&#x2F;    NSLog(@&quot;%@&quot;,_nameWithSetterGetter); &#x2F;&#x2F;这是调用_成员变量，错误提示为：（Use of undeclared identifier &#39;_nameWithSetterGetter&#39;）</span><br></pre></td></tr></table></figure>
<p><strong>问题解决。</strong></p>
<blockquote>
<p><strong>但是注意，以上代码仅仅是手动实现了</strong><code>setter/getter</code><strong>方法，但调用</strong><code>_成员变量</code><strong>依然报错。</strong></p>
</blockquote>
<h2 id="类扩展（Class-Extension）"><a href="#类扩展（Class-Extension）" class="headerlink" title="类扩展（Class Extension）"></a>类扩展（Class Extension）</h2><p>Extension是Category的一个特例。类扩展与分类相比只少了分类的名称，所以称之为“匿名分类”。<br>其实开发当中，我们几乎天天在使用。对于有些人来说像是最熟悉的陌生人。</p>
<h3 id="类扩展格式："><a href="#类扩展格式：" class="headerlink" title="类扩展格式："></a>类扩展格式：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@interface XXX ()</span><br><span class="line">&#x2F;&#x2F;私有属性</span><br><span class="line">&#x2F;&#x2F;私有方法（如果不实现，编译时会报警,Method definition for &#39;XXX&#39; not found）</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><blockquote>
<p>为一个类添加额外的原来没有变量，方法和属性<br>一般的类扩展写到<code>.m</code>文件中<br>一般的私有属性写到<code>.m</code>文件中的类扩展中</p>
</blockquote>
<hr>
<h2 id="类别与类扩展的区别："><a href="#类别与类扩展的区别：" class="headerlink" title="类别与类扩展的区别："></a>类别与类扩展的区别：</h2><blockquote>
<p>①类别中原则上只能增加方法（能添加属性的的原因只是通过<code>runtime</code>解决无<code>setter/getter</code>的问题而已）；<br>②类扩展不仅可以增加方法，还可以增加实例变量（或者属性），只是该实例变量默认是@private类型的（<br>用范围只能在自身类，而不是子类或其他地方）；<br>③类扩展中声明的方法没被实现，编译器会报警，但是类别中的方法没被实现编译器是不会有任何警告的。这是因为<strong>类扩展是在编译阶段被添加到类中，而类别是在运行时添加到类中</strong>。<br>④类扩展不能像类别那样拥有独立的实现部分（@implementation部分），也就是说，类扩展所声明的方法必须依托对应类的实现部分来实现。<br>⑤定义在 .m 文件中的类扩展方法为私有的，定义在 .h 文件（头文件）中的类扩展方法为公有的。类扩展是在 .m 文件中声明私有方法的非常好的方式。</p>
</blockquote>
<h2 id="点击下载Demo"><a href="#点击下载Demo" class="headerlink" title="点击下载Demo"></a><a href="https://github.com/walkertop/CategoryAndExtension--Demo" target="_blank" rel="noopener">点击下载Demo</a></h2><h2 id="最后总结："><a href="#最后总结：" class="headerlink" title="最后总结："></a>最后总结：</h2><p>关于分类，类扩展等问题，在很多概念性的东西网上讲解的很是模糊，而且在实际应用的背后的原理上也少有展开。作者写这篇文章的目的就是想让读者对分类，类扩展等常见的问题有个清晰的认识，免了看了记不住，记住又记不对，记对了又不明白原因。<br>在实际开发中，很多工具类都是分类，类扩展的实际应用，所以笔者后续会在我的个人GitHub上放出工具类，欢迎start和follow。<br>文章是本人通过实际代码和自己的开发经验整理而成，如果你喜欢我的文章，欢迎喜欢和打赏。技术的进步成长需要交流碰撞，也期待你的留言评论，不要只做一个MARK党。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://betteris.top/category%E5%92%8Cextension%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8%E6%94%BB%E7%95%A5/" data-id="ck55j78e30008akx985wq9q12" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/category/" rel="tag">category</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-深入runtime探究KVO" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E6%B7%B1%E5%85%A5runtime%E6%8E%A2%E7%A9%B6KVO/" class="article-date">
  <time datetime="2015-09-29T04:18:27.000Z" itemprop="datePublished">2015-09-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E6%B7%B1%E5%85%A5runtime%E6%8E%A2%E7%A9%B6KVO/">深入runtime探究KVO</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Objective-C 中的键(key)-值(value)观察(KVO)并不是什么新鲜事物,它来源于设计模式中的<code>观察者模式</code>,其基本思想就是:</p>
<blockquote>
<p>一个目标对象管理所有依赖于它的观察者对象,并在它自身的状态改变时主动通知观察者对象。这个主动通知通常是通过调用各观察者对象所提供的接口方法来实现的。观察者模式较完美地将目标对象与观察者对象解耦。</p>
</blockquote>
<p>在 Objective-C 中有两种使用键值观察的方式:手动或自动,此外还支持注册依赖键(即一个键依赖于 其他键,其他键的变化也会作用到该键)。下面将一一讲述这些,并会深入 Objective-C 内部一窥键值 观察是如何实现的。</p>
<hr>
<h2 id="观察者（Observer）"><a href="#观察者（Observer）" class="headerlink" title="观察者（Observer）"></a>观察者（Observer）</h2><blockquote>
<p><strong>观察者（Observer）</strong><br>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。<br>在 <code>Cocoa Touch</code> 框架中通知和 <code>KVO</code> 都实现了观察者模式。<strong>通知是由一个中心对象为所有观察者提供变更通知，<code>KVO</code> 是被观察的对象直接向观察者发送通知。</strong><br>如上图，<code>Subject</code> 的值改变时，通知观察者 <code>ObserverA</code>，<code>ObserverB</code>，<code>ObserverC</code>，我的数据改变了，依赖我的你们需要更新状态了。<br><code>被观察者不需要知道有多少个观察者和观察者的更新细节，降低被观察者和观察者之间的耦合</code>。</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/1467716-696c1f5f6fb7cab7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="observer.png"></p>
<h2 id="运用键值观察"><a href="#运用键值观察" class="headerlink" title="运用键值观察"></a>运用键值观察</h2><h3 id="1-注册与解除注册"><a href="#1-注册与解除注册" class="headerlink" title="1,注册与解除注册"></a>1,注册与解除注册</h3><p>如果我们已经有了包含可供键值观察属性的类,那么就可以通过在该类的对象(被观察对象)上调用名 为 NSKeyValueObserverRegistration 的 category 方法将观察者对象与被观察者对象注册与解除 注册:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath opt ions:(NSKeyValueObservingOptions)options context:(void *)context;</span><br><span class="line">- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath;</span><br></pre></td></tr></table></figure>

<p>这两个方法的定义在 <code>Foundation/NSKeyValueObserving.h</code> 中,<code>NSObject</code>,<code>NSArray</code>,<code>NSSet</code> 均实现了以上方法,因此我们不仅可以观察普通对象,还可以观察数组或结合类对象。在该头文件中,我们还 可以看到 NSObject 还实现了 <code>NSKeyValueObserverNotification</code> 的 <code>category</code> 方法(更多类似方 法,请查看该头文件):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)willChangeValueForKey:(NSString *)key;</span><br><span class="line">- (void)didChangeValueForKey:(NSString *)key;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong>不要忘记解除注册,否则会导致资源泄露。</p>
</blockquote>
<h3 id="2-设置属性"><a href="#2-设置属性" class="headerlink" title="2,设置属性"></a>2,设置属性</h3><p>将观察者与被观察者注册好之后,就可以对观察者对象的属性进行操作,这些变更操作就会被通知给观察 者对象。注意,只有遵循 KVO 方式来设置属性,观察者对象才会获取通知,也就是说遵循使用属性的 setter 方法,或通过 key-path 来设置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;必须是set方法</span><br><span class="line">target.age &#x3D; 30;</span><br><span class="line">[target setAge:30];</span><br><span class="line">[target setValue:[NSNumber numberWithInt:30] forKey:@&quot;age&quot;];</span><br></pre></td></tr></table></figure>

<h3 id="3-处理变更通知"><a href="#3-处理变更通知" class="headerlink" title="3,处理变更通知"></a>3,处理变更通知</h3><p>观察者需要实现名为 <code>NSKeyValueObserving</code> 的 <code>category</code> 方法来处理收到的变更通知:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：</strong>在这里<code>change</code> 这个字典保存了变更信息,具体是哪些信息取决于注册时 的 <code>NSKeyValueObservingOptions</code>。</p>
</blockquote>
<h2 id="KVO的内部实现原理："><a href="#KVO的内部实现原理：" class="headerlink" title="KVO的内部实现原理："></a>KVO的内部实现原理：</h2><p>KVO是基于<code>runtime</code>机制实现的，当某个类的属性对象第一次被观察时，系统就会在运行期间动态地创建该类的一个派生类，在这个派生类中重写基类的任何被观察属性的<code>setter</code>方法。派生类在被重写的setter方法内实现真正的通知机制<br>如果原类为<code>Person</code>，那么生成的派生类名为<code>NSKVONotifying_Person</code>。</p>
<p>我们知道，每一个类中都有一个<code>isa</code>指针指向当前类，所有系统就是在当一个类的对象第一次被观察的时候，系统就会偷偷将<code>isa</code>指针指向动态生成的派生类，从而在被监听属性赋值时被执行的是派生类的<code>setter</code>方法<br>键值观察通知依赖于<code>NSObject</code> 的两个方法: <code>willChangeValueForKey:</code> 和 <code>didChangevlueForKey:</code>;在一个被观察属性发生改变之前， <code>willChangeValueForKey:</code> 一定会被调用，这就 会记录旧的值。而当改变发生后，<code>didChangeValueForKey:</code> 会被调用，继而 <code>observeValueForKey: ofObject: change: context:</code> 也会被调用。</p>
<blockquote>
<p><strong>补充：</strong>KVO的这套实现机制中苹果还偷偷重写了class方法以“欺骗”外部调用者，让我们误认为还是使用的当前类，然后系统将这个对象的 isa 指针指向这个新诞生的派生类,因此这个对象就成为该派生类的对象了,因而在该对象上对 <code>setter</code> 的调 用就会调用重写的 <code>setter</code>,从而激活键值通知机制。此外,派生类还重写了 <code>dealloc</code> 方法来释放资源。</p>
</blockquote>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>技术学习绝不能孤胆英雄独闯天涯，而应在一群人的交流碰撞，享受智慧火花的狂欢。<br>希望我的文章能成为你的盛宴，也渴望你的建议能成为我的大餐。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://betteris.top/%E6%B7%B1%E5%85%A5runtime%E6%8E%A2%E7%A9%B6KVO/" data-id="ck55j78ec000iakx94mai17fq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/runtime-KVO/" rel="tag">runtime, KVO</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/KVC-Runtime/" rel="tag">KVC Runtime</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RAC/" rel="tag">RAC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RAC-MVVM/" rel="tag">RAC MVVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/YYModel/" rel="tag">YYModel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/category/" rel="tag">category</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS-RunLoop/" rel="tag">iOS RunLoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/runtime/" rel="tag">runtime</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/runtime-KVO/" rel="tag">runtime, KVO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/setter-getter/" rel="tag">setter/getter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/swift/" rel="tag">swift</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-%E5%B1%9E%E6%80%A7/" rel="tag">成员变量 属性</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag">读书笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/KVC-Runtime/" style="font-size: 10px;">KVC Runtime</a> <a href="/tags/RAC/" style="font-size: 20px;">RAC</a> <a href="/tags/RAC-MVVM/" style="font-size: 10px;">RAC MVVM</a> <a href="/tags/YYModel/" style="font-size: 10px;">YYModel</a> <a href="/tags/category/" style="font-size: 10px;">category</a> <a href="/tags/iOS-RunLoop/" style="font-size: 10px;">iOS RunLoop</a> <a href="/tags/runtime/" style="font-size: 20px;">runtime</a> <a href="/tags/runtime-KVO/" style="font-size: 10px;">runtime, KVO</a> <a href="/tags/setter-getter/" style="font-size: 10px;">setter/getter</a> <a href="/tags/swift/" style="font-size: 10px;">swift</a> <a href="/tags/%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-%E5%B1%9E%E6%80%A7/" style="font-size: 10px;">成员变量 属性</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 10px;">读书笔记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/page/">page</a>
          </li>
        
          <li>
            <a href="/swift%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%E5%B0%BF%E6%80%A7-%E8%AF%B4%E7%82%B9%E5%88%AB%E4%BA%BA%E6%B2%A1%E8%AE%B2%E6%98%8E%E7%99%BD%E7%9A%84%EF%BC%89/">swift的数据类型到底是什么尿性 (说点别人没讲明白的）</a>
          </li>
        
          <li>
            <a href="/0821%E6%9D%82%E8%B0%88/">0821杂谈</a>
          </li>
        
          <li>
            <a href="/%E7%B4%A7%E5%BC%A0%E5%85%AE%E5%85%AE%E7%9A%84%E4%B8%80%E4%B8%AA%E6%9C%88/">紧张兮兮的一个月</a>
          </li>
        
          <li>
            <a href="/%E3%80%8A%E6%8A%8A%E6%97%B6%E9%97%B4%E5%BD%93%E4%BD%9C%E6%9C%8B%E5%8F%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">《把时间当作朋友》读书笔记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Walker Guo<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>