<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Walker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Better is top!">
<meta property="og:type" content="website">
<meta property="og:title" content="Walker">
<meta property="og:url" content="http://betteris.top/index.html">
<meta property="og:site_name" content="Walker">
<meta property="og:description" content="Better is top!">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Walker">
<meta name="twitter:description" content="Better is top!">
  
    <link rel="alternate" href="/atom.xml" title="Walker" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Walker</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Better is top!</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://betteris.top"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-swift的数据类型到底是什么尿性-说点别人没讲明白的）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/swift的数据类型到底是什么尿性-说点别人没讲明白的）/" class="article-date">
  <time datetime="2017-08-22T13:03:09.000Z" itemprop="datePublished">2017-08-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/swift的数据类型到底是什么尿性-说点别人没讲明白的）/">swift的数据类型到底是什么尿性 (说点别人没讲明白的）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="文初："><a href="#文初：" class="headerlink" title="文初："></a>文初：</h2><p>如果你对swift的些许了解只局限在</p>
<ul>
<li>swift中的类型使用struct取代class</li>
<li>多了Optional可选类型</li>
</ul>
<p>这些最基础的认知，而对其底层设计的原因和原理了解甚少，那这篇文章会给你新的视角，让你更好的理解和使用。<br>为了让你能更宏观的理解swift在类型设计方面的初衷，本文会也会从更加宏观的角度着手。</p>
<p>其实swift的类型，从大的层面有两种类型：</p>
<ul>
<li>Named Types</li>
<li>Compound Types</li>
</ul>
<h2 id="Named-Types"><a href="#Named-Types" class="headerlink" title="Named Types"></a>Named Types</h2><p>其具体包含如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">* class </div><div class="line">* struct </div><div class="line">     &#123;</div><div class="line">         * String</div><div class="line">         * Int</div><div class="line">         * Float</div><div class="line">         * Bool</div><div class="line">         * ...</div><div class="line">     &#125;</div><div class="line"> * enum</div><div class="line"> * protocol</div></pre></td></tr></table></figure>
<h3 id="swift类型的新特点（区别与OC）："><a href="#swift类型的新特点（区别与OC）：" class="headerlink" title="swift类型的新特点（区别与OC）："></a>swift类型的新特点（区别与OC）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">* 没有特定的根类型（No dedicated type root ）</div><div class="line">* 类型通过遵守协议的方式，而非继承来实现扩展（ Type conforms to protocols instead of heavy inheritance ）</div><div class="line">* 低耦合（Super loose coupling ）</div><div class="line">* 概念分离（Nice separation of concerns ）</div><div class="line">* 结构清晰（Clean architecture ）</div></pre></td></tr></table></figure>
<p>对比OC，所有的对象类型都继承自NSObject，其本质是Class类型。<br>为了保证继承的完整性，又多出了meta class等概念。Class中通过继承来实现的方法的扩展。</p>
<p>比如：NSArray及NSMutableArray类型<br>NSMutableArray是NSArray的子类。子类NSMutableArray特有的<code>addObject:</code>等方法是通过继承NSArray,在子类中单独实现。</p>
<p><img src="http://oiu13lwmh.bkt.clouddn.com/15033951098490.jpg" alt="OC通过继承扩展方法"></p>
<p>这种设计本身无可挑剔，但OC过于依赖继承来实现方法的扩展，导致整个体系特别臃肿，过于耦合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@interface AClass: NSObject</div><div class="line"></div><div class="line">- (void)aMethod;</div><div class="line">- (void)bMethod;</div><div class="line"></div><div class="line">- (void)oneMethod;</div><div class="line">- (void)twoMethod;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">//BClass想拥有aMethod和bMethod方法，不需要oneMethod和twoMethod,在OC一般都继承实现</div><div class="line">@interface BClass: AClass</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>而swift不过度依赖Class，其扩展了Struct，Enum, Protocol，并给其更高的权限（可更加灵活的添加属性，定义方法等），让其变成一等公民。</p>
<p>swift底层是结构体，结构体不是对象类型，自然没办法通过继承来实现方法扩展。那其方法实现是通过何种方式完成的呢？<br>答案是协议，不同的协议包裹了不同的方法，通过遵守不同的协议来扩展特定的方法。</p>
<p>对于上述需求，在swift中一般通过如下方法实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// swift通过protocol来扩充方法，通过遵守不同的协议来获取不同方法，更偏重组合，而非继承</div><div class="line">protocol FirstProtocol &#123;</div><div class="line">    func aMethod()</div><div class="line">    func bMethod()</div><div class="line">&#125;</div><div class="line"></div><div class="line">protocol SecondProtocol &#123;</div><div class="line">    func oneMethod()</div><div class="line">    func twoMethod()</div><div class="line">&#125;</div><div class="line"></div><div class="line">class AClass: FirstProtocol,SecondProtocol &#123;</div><div class="line">    //实现两个方法</div><div class="line">&#125;</div><div class="line"></div><div class="line">class BClass: FirstProtocol &#123;</div><div class="line">    //实现两个方法</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>比如Array类型，其通过继承不同的协议来获取不同的方法。<br><img src="http://oiu13lwmh.bkt.clouddn.com/15033835889832.jpg" alt="Array遵守的协议"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">* 类比理解：</div><div class="line"></div><div class="line">继承更讲究出身，尤其OC是单继承，只能有一个父类，你想获取父类制定的方法，必须继承父类。</div><div class="line">而面向协议则更加灵活，不同的protocol封装了不同的技能包，某个类型想要获取对应方法，只需遵守该protocol就ok了。而且一个类型可以遵守多个协议，更加灵活。而且Enum,Struct都可以通过遵守协议来获取方法。</div></pre></td></tr></table></figure>
<hr>
<h2 id="Compound-Types-复合类型）"><a href="#Compound-Types-复合类型）" class="headerlink" title="Compound Types (复合类型）"></a>Compound Types (复合类型）</h2><ul>
<li>Tuples（元组）</li>
<li>Function（函数）</li>
</ul>
<h3 id="Tuples-Types"><a href="#Tuples-Types" class="headerlink" title="Tuples Types"></a>Tuples Types</h3><p>Tuples（元组）是swift的新类型。其成员不同，Tuple类型就不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var aTuple = (x: 10, y: 20)</div><div class="line">// 此时就会报错，x的类型只能是Int</div><div class="line">// aTuple = (x: &quot;name&quot;, y: 50)</div></pre></td></tr></table></figure>
<p>当Tuples作为函数的返回值类型，就可以返回多个值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let nameDictionary: [Int: String] = [001: &quot;Jimmy&quot;]</div><div class="line">let ageDictionary: [Int: Int] = [001: 20]</div><div class="line"></div><div class="line">func getInformationFrom (ID: Int) -&gt; (name: String, age: Int) &#123;</div><div class="line">    let name = nameDictionary[ID] ?? &quot;找不到对应的名字&quot;</div><div class="line">    let age = ageDictionary[ID] ?? 0</div><div class="line">    </div><div class="line">    return (name, age)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Function-Types"><a href="#Function-Types" class="headerlink" title="Function Types"></a>Function Types</h3><p>swift将Function（函数）提升为一等类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">let nameDictionary: [Int: String] = [001: &quot;Jimmy&quot;]</div><div class="line">let ageDictionary: [Int: Int] = [001: 20]</div><div class="line"></div><div class="line">func getInformationFrom (ID: Int) -&gt; (name: String, age: Int) &#123;</div><div class="line">    let name = nameDictionary[ID] ?? &quot;找不到对应的名字&quot;</div><div class="line">    let age = ageDictionary[ID] ?? 0</div><div class="line">    </div><div class="line">    return (name, age)</div><div class="line">&#125;</div><div class="line">// 用aPerson接受这个函数，类型为一个元组类型,值为(name: &quot;Jimmy&quot;, age: 20)</div><div class="line">let aPerson = getInformationFrom(ID: 001)</div></pre></td></tr></table></figure>
<h3 id="Blocks-VS-Closures（闭包）"><a href="#Blocks-VS-Closures（闭包）" class="headerlink" title="Blocks VS Closures（闭包）"></a>Blocks VS Closures（闭包）</h3><p>swift中的closure类似于OC的block，但还是有些区别。</p>
<p><img src="http://oiu13lwmh.bkt.clouddn.com/Blocks%20VS%20Closures.png" alt="Blocks VS Closures"></p>
<h5 id="关于两者语法的不同，可以参考"><a href="#关于两者语法的不同，可以参考" class="headerlink" title="关于两者语法的不同，可以参考"></a>关于两者语法的不同，可以参考</h5><p><a href="http://fuckingblocksyntax.com/" target="_blank" rel="external">Block Syntax</a>  and <a href="http://fuckingclosuresyntax.com" target="_blank" rel="external">Closure Syntax</a></p>
<h3 id="Function-VS-Closures"><a href="#Function-VS-Closures" class="headerlink" title="Function VS Closures"></a>Function VS Closures</h3><p>A closure is actually a higher usage of a function type. Above, we just have two types of types; the closure is defined quite similarly to the function itself. This is because it takes the parameters and the area and the return type just as the type signage. This makes functions and closures siblings.</p>
<h2 id="Optional可选类型"><a href="#Optional可选类型" class="headerlink" title="Optional可选类型"></a>Optional可选类型</h2><p>swift中的Optional底层就是一个带泛型的枚举类型。</p>
<p>其源码抽象出来如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public enum Optional&lt;Wrapped&gt; : ExpressibleByNilLiteral &#123;</div><div class="line">    case none</div><div class="line">    case some(Wrapped)</div><div class="line">    </div><div class="line">    public init(_ some: Wrapped)</div><div class="line">    public init(nilLiteral: ())</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 此时定义中的Wrapped就是String类型</div><div class="line">var myName : String? = &quot;Walker&quot;</div><div class="line">	print(myName)</div><div class="line">	print(myName!)</div><div class="line"></div><div class="line">	if let name = myName &#123;</div><div class="line">		print(name)</div><div class="line">	&#125;</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://betteris.top/swift的数据类型到底是什么尿性-说点别人没讲明白的）/" data-id="ck76887d0000elvx9jy41t1b3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/swift/">swift</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-0821杂谈" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/0821杂谈/" class="article-date">
  <time datetime="2017-08-21T10:43:42.000Z" itemprop="datePublished">2017-08-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/0821杂谈/">0821杂谈</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h2 id="子弹是否要为战争奔赴沉重感"><a href="#子弹是否要为战争奔赴沉重感" class="headerlink" title="子弹是否要为战争奔赴沉重感"></a>子弹是否要为战争奔赴沉重感</h2><p>没有一朵云觉得需要对整场暴风雨负责。<br>当你是机器里一个螺丝钉的时候，你是否有责任为这个机器生产出来的产品负责？<br>柏林墙前，面对强行翻越围墙的人，<br>执行射击命令，作为士兵没有错；<br>但人性光辉下，枪口抬高一尺，是你另外一重身份给你的选择。<br>所以，在特殊场景下，以为没有的选择，也可能在人性的光辉下，让你停下来思考你在做什么，应该怎么做。</p>
<h2 id="中国高端阶层的消费变迁"><a href="#中国高端阶层的消费变迁" class="headerlink" title="中国高端阶层的消费变迁"></a>中国高端阶层的消费变迁</h2><p>现在的消费场景从土豪消费过渡到无形消费。<br>首先要说，不要痛恨阶层，人性使然，阶层的划分是必然。<br>现在的高端阶层，曾经通过显摆式的物质消费，以物质的高贵和直接的拥有来显示身份的高贵开始过渡到以无形消费为阶层划分的标识。</p>
<p>因为，财富爆发初期的欣喜阶段，新鲜劲过后，有形物品的并不能让人得到持续的满足，也不足以区分基层之间的差异。<br>所以资源，人脉圈，教育，涵养等无形消费品开始成为阶层划分的新标识。<br>而传统观念认为巨富出纨绔，富不过三代的理念开始翻转，阶层的划分，从以往的财富为标识的分层开始转变为涵养分层，价值观分层。</p>
<p>毕竟先富阶层，更容易先达到繁华落尽，归于平淡。并不以物质满足为核心诉求，最先开始物质以外的寻找。<br>举个栗子，富人会更先认同喜欢慈善，通过财富来换取道德层面的满足感是值得的。金钱上已经富起来，精神上富起来便是下一个追求。</p>
<p>而往往穷人更渴望获得物质满足，并不会刻意追求道德感。物质的匮乏会让穷人的劣根性更多展现，抱怨也会更多。<br>这种增强式的反馈，也会加强阶层固化，加深阶层分层。</p>
<p>然而阶层本身不是敌人，阶层之间的对立才是可怕的，阶层之间的抱怨就会引起仇恨，更多渴望通过动乱来解决阶层矛盾。<br>这种动荡的因子才是最致命的。</p>
<h2 id="媒体的百花（“挣“）（”命”）"><a href="#媒体的百花（“挣“）（”命”）" class="headerlink" title="媒体的百花（“挣“）（”命”）"></a>媒体的百花（“挣“）（”命”）</h2><p>权威媒体不权威，自媒体为了吸引注意力，哗众取宠的腔调就成了突破重围的方式。</p>
<p>不负责任的标题党，<br>以偏概全博眼球，<br>驴唇马嘴的论据结论都成了可以利用的手段。<br>以至于现在的媒体氛围到达了“表态大于关注事实”，为了挑起好事之人的胃口，把话往极端方向说，事往极端方向扯，就为了火起来。<br>就连新闻媒体忌讳的偷换概念也成了媒体人的专业素养。<br>一大堆论据不充分的论证，杂糅事实和欺骗，故意搅浑整个汤。<br>即使事实正确的论述，也不足以说明道理正确。</p>
<p>当然，无论什么样的文章，放诸人海，均有受众，总能吊起一部分人的情绪。<br>哪怕权威文章，也无法保证所有人的认同。<br>没有绝对的真理，只有选择的阵营。<br>毕竟对于大部分人，看完一篇文章只会得出单向的结论。<br>其根据占据观点的不同，必然会分化成两个阵营。<br>当然也不否认有极少数的人，具备区分两种观点的能力。<br>故而很多文章，结论的片面性是由于观众自己的片面性决定的。<br>其文章的片面性并不妨碍有些人为此买单。<br>甚至很多人现在不再关心结论，更多的是关心现场，现象产生的共鸣让很多不深入思考的人也能掀起波澜。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://betteris.top/0821杂谈/" data-id="ck76887ck0000lvx9jm026jjz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-紧张兮兮的一个月" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/紧张兮兮的一个月/" class="article-date">
  <time datetime="2017-07-10T03:09:01.000Z" itemprop="datePublished">2017-07-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/紧张兮兮的一个月/">紧张兮兮的一个月</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>紧张兮兮的大半个月。<br>从0619决定换工作，但现在想阶段性的休息调整，经历了大变。</p>
<p>不断的回顾基础，刷面试题，回顾自己的iOS的工作和学习。<br>到后来跳槽开始变的不那么坚决，这个过程很疲惫。不断的发问，想明白自己到底想要什么，也逐渐捋清楚，想明白，最终决定给自己两个月的时间做自己想做的事情。</p>
<p>好久都想拾掇起来的英语，一直是我的一块心病，在猎头计划推荐我类似AirBnb的外企时，一次次感觉被重创。“你能用英语表达你做的项目么？”，“你能用英语和开发人员进行交流么？”。<br>画面让我回想当年去越南时的窘境，稀稀落落的通过单词表达意思，通过pardon来明白对话。现在想起来也是大写的尴尬。</p>
<p>暂缓的另一个原因是，始终坚持想去A和T，从模糊到明确，最后坚定下来，想找个大厂的背景。可惜现在的坑不多了，只能等等看。</p>
<p>后来就开始想象，余下来两个月的时间，有更多的机会让我自己去学习，也趁着这样的计划，好好梳理下我的规划。</p>
<p>想拾掇起来，开发个自己的APP，也算为未来的被动收入增加个尝试和可能性。</p>
<p>最近部门很多小伙伴不断离职，坦白来说，还是有点心慌着急，梳理梳理，突然觉得淡定了不少。</p>
<p>静待花开，芳香自来。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://betteris.top/紧张兮兮的一个月/" data-id="ck76887d7000qlvx9jg1v49q5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-《把时间当作朋友》读书笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/《把时间当作朋友》读书笔记/" class="article-date">
  <time datetime="2017-03-13T08:10:53.000Z" itemprop="datePublished">2017-03-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/《把时间当作朋友》读书笔记/">《把时间当作朋友》读书笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、单向成立"><a href="#一、单向成立" class="headerlink" title="一、单向成立"></a>一、单向成立</h2><h4 id="名人的成功经验有毒"><a href="#名人的成功经验有毒" class="headerlink" title="名人的成功经验有毒"></a>名人的成功经验有毒</h4><ol>
<li><p>正确的顺序是因素导致结果。成功的方式是不唯一的，导致成功的因素显然不是导致结果的充分且必要条件。坦白来讲，除了努力，聪明等优秀品质之外，机遇，运气，背景等偶然因素。</p>
</li>
<li><p>成功 = 必然因素 + 偶然因素。成功是各种因素的加权，方式不具备唯一性。</p>
</li>
<li><p>成功是一系列因素的加权之和，其方式不具备唯一性。很多因素并非充分必要条件。因此所谓名人采访，是一种从结果出发的倒退，不具备普遍性，只是单向成立而已。故而不能把成功者的经验当做一种信仰和教条。“欲练此功，必先自宫”的后一句“就算自宫也未必成功”</p>
</li>
</ol>
<h4 id="主观放大某些因素"><a href="#主观放大某些因素" class="headerlink" title="主观放大某些因素"></a>主观放大某些因素</h4><ol>
<li><p>因素A是助推成功的因素之一，但A是否是必要和不可或缺性，是一个疑问。即使是必要因素，其所占权重往往会因为我们主观因素，过于提高或者降低其比重。因此制定计划时，不要拖入一个主观状态，最好的方式就是仔细考量，适当放慢脚步，去沉淀整个计划方案，避免因暂时性的头脑一热，制定出难以实践的行动计划。</p>
</li>
<li><p>回想一下，我们时常在听了某个励志演讲，或者捕获新的方法时，感觉醍醐灌顶，从而着急忙慌，忽略客观事实和自身不足来制定不可行的计划。</p>
</li>
<li><p>slow down and think again.不仅仅不要冲动消费，也不要冲动计划。</p>
</li>
</ol>
<h4 id="“因为A所以B”的逻辑错误"><a href="#“因为A所以B”的逻辑错误" class="headerlink" title="“因为A所以B”的逻辑错误"></a>“因为A所以B”的逻辑错误</h4><ol>
<li><p>如果一个人是正确的，他的世界也是正确的。这是一种逻辑错误，是偷换概念。</p>
</li>
<li><p>爱迪生的案例告诉他的成功很大愿意是因为努力和勤奋，但无法证明你像爱迪生一样努力就一定能成功。不忽略因素的重要性，但更要思考因为A所以B成立的逻辑性。</p>
</li>
</ol>
<hr>
<h2 id="二、做好与兴趣"><a href="#二、做好与兴趣" class="headerlink" title="二、做好与兴趣"></a>二、做好与兴趣</h2><h4 id="顺序错误（是先做好了才更有兴趣，而非没有兴趣所以做不好）"><a href="#顺序错误（是先做好了才更有兴趣，而非没有兴趣所以做不好）" class="headerlink" title="顺序错误（是先做好了才更有兴趣，而非没有兴趣所以做不好）"></a>顺序错误（是先做好了才更有兴趣，而非没有兴趣所以做不好）</h4><ol>
<li>做不好是因为不感兴趣是比较狭隘的。不感兴趣的原因很大程度是因为你没有做好，所以学习的过程很苦恼，但结果的不良反馈加深了你不的不感兴趣，这实际就是一种不良的反馈循环。</li>
</ol>
<ol>
<li>同样反过来，努力做好，用良好的结果刺激来让你享受这个事物，从而形成反馈来确保你的兴趣。这就是一个良性循环。</li>
</ol>
<h4 id="很多人是没有能力做好才说不感兴趣，不自觉的回避自己的短处，如果该事物是你不得不的选择，无论热爱与否，just-do-it-you-will-love-it"><a href="#很多人是没有能力做好才说不感兴趣，不自觉的回避自己的短处，如果该事物是你不得不的选择，无论热爱与否，just-do-it-you-will-love-it" class="headerlink" title="很多人是没有能力做好才说不感兴趣，不自觉的回避自己的短处，如果该事物是你不得不的选择，无论热爱与否，just do it, you will love it."></a>很多人是没有能力做好才说不感兴趣，不自觉的回避自己的短处，如果该事物是你不得不的选择，无论热爱与否，just do it, you will love it.</h4><hr>
<h2 id="三、“方法技巧”与“坚持耐心”"><a href="#三、“方法技巧”与“坚持耐心”" class="headerlink" title="三、“方法技巧”与“坚持耐心”"></a>三、“方法技巧”与“坚持耐心”</h2><h4 id="方法很重要，但成功的核心是坚持和耐心"><a href="#方法很重要，但成功的核心是坚持和耐心" class="headerlink" title="方法很重要，但成功的核心是坚持和耐心"></a>方法很重要，但成功的核心是坚持和耐心</h4><ol>
<li>方法和坚持是成功的两大因素，但坚持本身就是最重要的方法。如果没有坚持，再好的方法也是无用功。</li>
<li>半途而废本身就是虚度时间</li>
</ol>
<h4 id="错误的方法论"><a href="#错误的方法论" class="headerlink" title="错误的方法论"></a>错误的方法论</h4><ol>
<li>过于强调方法论，一事无成的根本原因是因为放弃，放弃的理由之一就是换一个更好的方法和方向。你在行进的过程中会不断发现更好的方法，但更好的方法本身是不存在的。所以比起方法，最好的方式是先经过一段时间的坚持，然后再调整方法，以免在不断的调整方向中迷失了方向，最终放弃。</li>
<li>坚持到底未必成功，但失败归根结底就是“半途而废”。</li>
</ol>
<h4 id="初始阶段，计划的不可靠性。"><a href="#初始阶段，计划的不可靠性。" class="headerlink" title="初始阶段，计划的不可靠性。"></a>初始阶段，计划的不可靠性。</h4><ol>
<li>初始状态，在没有行动经验时是没有能力制定合理有效的计划的，所以最好的方式就是先坚持，入门，然后熟悉，再摸索，反思，调整到最后找到合适的方法，直到成功。再没有初始认知时，一切都是空谈。所谓的计划不如变化，大抵如此。</li>
<li>先行动，行动中打磨计划</li>
</ol>
<hr>
<h2 id="四、认知偏差（愿望中的我，真实的我，感觉的我）"><a href="#四、认知偏差（愿望中的我，真实的我，感觉的我）" class="headerlink" title="四、认知偏差（愿望中的我，真实的我，感觉的我）"></a>四、认知偏差（愿望中的我，真实的我，感觉的我）</h2><h4 id="最理想的状态"><a href="#最理想的状态" class="headerlink" title="最理想的状态"></a><strong>最理想的状态</strong></h4><p> <code>愿望中的我 = 真实的我 = 感觉的我</code>  </p>
<h4 id="特别的受挫和自卑"><a href="#特别的受挫和自卑" class="headerlink" title="特别的受挫和自卑"></a><strong>特别的受挫和自卑</strong></h4><p><code>愿望中的我  &gt;&gt;  现实的我   || 愿望中的我  &gt;&gt;  感觉的我</code> </p>
<h4 id="自负"><a href="#自负" class="headerlink" title="自负"></a><strong>自负</strong></h4><p><code>感觉的我 &gt;&gt; 真实的我</code> </p>
<hr>
<h2 id="五、时间预算"><a href="#五、时间预算" class="headerlink" title="五、时间预算"></a>五、时间预算</h2><h4 id="制定时间规划时，要留有部分空间来缓冲意外时间的发生"><a href="#制定时间规划时，要留有部分空间来缓冲意外时间的发生" class="headerlink" title="制定时间规划时，要留有部分空间来缓冲意外时间的发生"></a>制定时间规划时，要留有部分空间来缓冲意外时间的发生</h4><h4 id="吃青蛙战略：困难的事情优先做，擅长的事情放到后面是优势策略；"><a href="#吃青蛙战略：困难的事情优先做，擅长的事情放到后面是优势策略；" class="headerlink" title="吃青蛙战略：困难的事情优先做，擅长的事情放到后面是优势策略；"></a>吃青蛙战略：困难的事情优先做，擅长的事情放到后面是优势策略；</h4><h4 id="养成时间记录的习惯，记录时间花费，线性追踪"><a href="#养成时间记录的习惯，记录时间花费，线性追踪" class="headerlink" title="养成时间记录的习惯，记录时间花费，线性追踪"></a>养成时间记录的习惯，记录时间花费，线性追踪</h4><h4 id="任何事情之前，先花费时间去分析完成任务的技能，做出宏观规划，"><a href="#任何事情之前，先花费时间去分析完成任务的技能，做出宏观规划，" class="headerlink" title="任何事情之前，先花费时间去分析完成任务的技能，做出宏观规划，"></a>任何事情之前，先花费时间去分析完成任务的技能，做出宏观规划，</h4><pre><code>1. 明白欠缺部分
2. 测算时间花费
3. 分析所需技能
4. 明确优缺点和擅长与否
</code></pre><h4 id="明白时间不是百分百高效，合理安排"><a href="#明白时间不是百分百高效，合理安排" class="headerlink" title="明白时间不是百分百高效，合理安排"></a>明白时间不是百分百高效，合理安排</h4><hr>
<h2 id="六、名言的价值"><a href="#六、名言的价值" class="headerlink" title="六、名言的价值"></a>六、名言的价值</h2><p>很有明明很有道理的名言却很难有效传递。究其根本是由于这些经验需要很长的时间总结得来，所以听者缺乏现有的经验去感受，没有相似的经历去类比，所以很难形成有效的传递。</p>
<hr>
<h2 id="七、起始的偏差对全局的影响"><a href="#七、起始的偏差对全局的影响" class="headerlink" title="七、起始的偏差对全局的影响"></a>七、起始的偏差对全局的影响</h2><ol>
<li>对初始条件的敏感性依赖，同端点的射线，随着时间的延长，其差距愈加明显。蝴蝶效应中，某一个蝴蝶翅膀的震动导致飓风。起始阶段，微乎其微的差异在最终位置会造成指数级的差别。</li>
<li>习惯不同就决定人处于不同的起始阶段，所以习惯具有放大性。</li>
</ol>
<hr>
<h2 id="八、独特性的分量"><a href="#八、独特性的分量" class="headerlink" title="八、独特性的分量"></a>八、独特性的分量</h2><ol>
<li>独特性并不等同于稀缺性<br>每个人都是独特的，这是客观事实。但就因为每个人都很特殊，这是一种普遍的独特性，不具备稀缺性，所以大部分人仍属于具有完全独特性的芸芸众生中里的一份子。无它。</li>
<li>大多数事情符合正太分布，决定你与众不同的是，你落在了正态分布的两侧。<h2 id="完美主义者的失败"><a href="#完美主义者的失败" class="headerlink" title="完美主义者的失败"></a>完美主义者的失败</h2></li>
</ol>
<h5 id="完美主义者的拖延"><a href="#完美主义者的拖延" class="headerlink" title="完美主义者的拖延"></a>完美主义者的拖延</h5><p>过于完美主义会导致拖延</p>
<h5 id="完美主义者的付出代价"><a href="#完美主义者的付出代价" class="headerlink" title="完美主义者的付出代价"></a>完美主义者的付出代价</h5><ol>
<li>学习氛围根据入门和瓶颈两个节点分为入门期，线性增长期和瓶颈期。等同时间的付出，在不同阶段获得的会把不同，最大的价值是在线性增长阶段（入门之后，瓶颈期之前），在瓶颈期付出很大的时间代价，往往只能获得很少的结果反馈。</li>
<li>因此在非专业领域的“不求甚解”往往是一种睿智的选择。但也要注意，高手之间的细小差距不是短时间就能追赶的，百米比赛中0.1s的确是明显的差距。</li>
</ol>
<hr>
<h2 id="你没有克服XX，只是习惯了XX"><a href="#你没有克服XX，只是习惯了XX" class="headerlink" title="你没有克服XX，只是习惯了XX"></a>你没有克服XX，只是习惯了XX</h2><p>你没有克服拖延，只是习惯了拖延；<br>你没有克服懒惰，只是习惯了懒惰；<br>你没有明白无知，只是习惯了无知；</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://betteris.top/《把时间当作朋友》读书笔记/" data-id="ck76887cy000clvx9f8vjxo7o" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/读书笔记/">读书笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-解释automaticallyAdjustsScrollViewInsets，extendedLayoutIncludesOpaqueBars，edgesForExtendedLayout的不同" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/解释automaticallyAdjustsScrollViewInsets，extendedLayoutIncludesOpaqueBars，edgesForExtendedLayout的不同/" class="article-date">
  <time datetime="2017-01-19T04:36:23.000Z" itemprop="datePublished">2017-01-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/解释automaticallyAdjustsScrollViewInsets，extendedLayoutIncludesOpaqueBars，edgesForExtendedLayout的不同/">解释automaticallyAdjustsScrollViewInsets，extendedLayoutIncludesOpaqueBars，edgesForExtendedLayout的不同</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>从iOS7开始，控制器就默认添加了全屏属性，因此，你就有更多的方式去操作view的布局，具体用到的属性包括：</p>
<ul>
<li>edgesForExtendedLayout</li>
<li>automaticallyAdjustsScrollViewInsets</li>
<li>extendedLayoutIncludesOpaqueBars</li>
</ul>
<hr>
<h2 id="edgesForExtendedLayout"><a href="#edgesForExtendedLayout" class="headerlink" title="edgesForExtendedLayout"></a><code>edgesForExtendedLayout</code></h2><p>我们可以根据以上属性设置view的铺满样式。<br>想象一下，默认情况下，我们从一个普通的UIViewController跳转到一个UINavigationController，view默认的展示样式是从导航栏底部开始。<br>但是你可以通过设置<code>edgesForExtendedLayout</code>为不同类型来控制view的样式(top, left, bottom, right)。</p>
<p>可以看一下例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">UIViewController *viewController = [[UIViewController alloc] init];</div><div class="line">viewController.view.backgroundColor = [UIColor redColor];</div><div class="line">UINavigationController *mainNavigationController = [[UINavigationController alloc] initWithRootViewController:viewController];</div></pre></td></tr></table></figure></p>
<p>你没有设置<code>edgesForExtendedLayout</code>的值，其默认的值是<code>UIRectEdgeAll</code>，所以view是延伸到整个屏幕的高度。<br>效果如下图：<br><img src="https://i.stack.imgur.com/MOB6v.png" alt=""></p>
<p>如你所见，红色背景延伸到了状态栏（status bar）下面。<br>假若你将 <code>edgesForExtendedLayout</code>的值设置为<code>UIRectEdgeNone</code>，意味着你告诉view不要讲其扩展到整个屏幕。<br>其效果如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">UIViewController *viewController = [[UIViewController alloc] init];</div><div class="line">viewController.view.backgroundColor = [UIColor redColor];</div><div class="line">viewController.edgesForExtendedLayout = UIRectEdgeNone;</div><div class="line">UINavigationController *mainNavigationController = [[UINavigationController alloc] initWithRootViewController:viewController];</div></pre></td></tr></table></figure>
<p><img src="https://i.stack.imgur.com/ojAvO.png" alt=""></p>
<hr>
<p>关于另外一个属性<code>automaticallyAdjustsScrollViewInsets</code>.<br>这个属性属于UIScrollView或包含UIScrollView的控制器（比如UITableView继承自UIScrollView，UIWebView中也包含UIScrollView）。<br>如果你想要你的view从导航栏底部开始，但是在滑动时，让其穿透到导航栏的底部。<br>在这种情况下，如果你将<code>edgesForExtendedLayout</code>设置为<code>UIRectEdgeNone</code>，虽然可以从导航栏底部开始，但滑动时无法穿透到导航栏底部。</p>
<p>怎么办呢？</p>
<p>这时候就显示出<code>automaticallyAdjustsScrollViewInsets</code>的作用了。<br>如果你将<code>edgesForExtendedLayout</code>的值设置为<code>UIRectEdgeAll</code>，<code>automaticallyAdjustsScrollViewInsets</code>设置为YES(<code>edgesForExtendedLayout</code>默认为<code>UIRectEdgeAll</code>，<code>automaticallyAdjustsScrollViewInsets</code>默认就是YES),就能实现上述需求。<br>具体如下图：<br><img src="https://i.stack.imgur.com/9Iapl.png" alt=""><br>上图是将<code>edgesForExtendedLayout</code>设置为<code>UIRectEdgeAll</code>，<code>automaticallyAdjustsScrollViewInsets</code>默认就是NO的情况)。</p>
<hr>
<p>下图是将<code>edgesForExtendedLayout</code>设置为<code>UIRectEdgeAll</code>，<code>automaticallyAdjustsScrollViewInsets</code>默认就是YES的情况)(也就是系统默认情况)<br><img src="https://i.stack.imgur.com/VVQHQ.png" alt=""></p>
<hr>
<p>关于另外一个属性。<br>字面意思是：是否延伸到包含不透明的状态栏。</p>
<ul>
<li><code>extendedLayoutIncludesOpaqueBars</code><br>这个值是一个补充,默认值是NO;<br>默认的苹果的状态栏（status bar）是透明的。如果状态栏不透明，这个试图就不回扩展到不透明的状态栏底部，除非将其值设置为YES<br>This value is just an addition to the previous ones. If the status bar is opaque, the views won’t be extended to include the status bar too, unless this parameter is YES.<br>所以如果状态栏不透明，即使你设置<code>edgesForExtendedLayout</code> 为 <code>UIRectEdgeAll</code>，<code>extendedLayoutIncludesOpaqueBars</code>为NO(默认如此)，view不会延伸到状态栏底部的。</li>
</ul>
<hr>
<h4 id="怎么判断UIScrollView在使用？"><a href="#怎么判断UIScrollView在使用？" class="headerlink" title="怎么判断UIScrollView在使用？"></a>怎么判断UIScrollView在使用？</h4><p>iOS会抓取控制器view的第一个子视图，（也就是index = 0），如果是UIScrollView或者UIScrollView的子类，就可以使用上文描述的属性。</p>
<p>如果视图是普通的UIView，可以添加一个线来解决。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.navigationController.navigationBar.translucent = NO;</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://betteris.top/解释automaticallyAdjustsScrollViewInsets，extendedLayoutIncludesOpaqueBars，edgesForExtendedLayout的不同/" data-id="ck76887d9000ulvx9aal0stda" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-一篇文章全吃透—史上最全YYModel的使用详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/一篇文章全吃透—史上最全YYModel的使用详解/" class="article-date">
  <time datetime="2016-07-19T04:32:49.000Z" itemprop="datePublished">2016-07-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/一篇文章全吃透—史上最全YYModel的使用详解/">一篇文章全吃透—史上最全YYModel的使用详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>开篇说明：</strong><br>虽然网上有很多讲解YYModel使用方法的文章，包括YYModel作者也在github上对其做了使用说明。<br>但在我实际使用过程中，依然发现文档的不完善，比如对于复杂的模型（如多层嵌套）讲解的仍不透彻，同时本文也会介绍一神器配合YYModel使用，让你感受分分钟搞定模型创建的酸爽。<br>当然为了减少读者的学习成本，本会对YYModel作者的文档进行丰富和扩展。<br>可在github上下载<a href="https://github.com/walkertop/YYModel---Demo" target="_blank" rel="external">Demo</a>，以便更直观了解各种使用场景详细代码。<br>文章只要包含：</p>
<blockquote>
<ul>
<li><ol>
<li>详解YYModel的多种使用场景</li>
</ol>
</li>
<li><ol>
<li>拓展插件，让你一分钟搞定所有的模型的创建和调用。</li>
</ol>
</li>
</ul>
</blockquote>
<h2 id="一、YYModel的使用场景"><a href="#一、YYModel的使用场景" class="headerlink" title="一、YYModel的使用场景"></a>一、YYModel的使用场景</h2><h3 id="1-简单的-Model-与-JSON-相互转换"><a href="#1-简单的-Model-与-JSON-相互转换" class="headerlink" title="1.简单的 Model 与 JSON 相互转换"></a>1.简单的 Model 与 JSON 相互转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// JSON:</div><div class="line">&#123;</div><div class="line">    &quot;uid&quot;:123456,</div><div class="line">    &quot;name&quot;:&quot;Harry&quot;,</div><div class="line">    &quot;created&quot;:&quot;1965-07-31T00:00:00+0000&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Model:</div><div class="line">@interface User : NSObject</div><div class="line">@property UInt64 uid;</div><div class="line">@property NSString *name;</div><div class="line">@property NSDate *created;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation User</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 将 JSON (NSData,NSString,NSDictionary) 转换为 Model:</div><div class="line">User *user = [User yy_modelWithJSON:json];</div><div class="line"></div><div class="line">// 将 Model 转换为 JSON 对象:</div><div class="line">NSDictionary *json = [user yy_modelToJSONObject];</div></pre></td></tr></table></figure>
<p> JSON/Dictionary 中的对象类型与 Model 属性不一致时，YYModel 将会进行如下自动转换。自动转换不支持的值将会被忽略，以避免各种潜在的崩溃问题。<br><img src="http://upload-images.jianshu.io/upload_images/1467716-33ae643a0ca314fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="格式自动转换.png"></p>
<h4 id="2-Model-属性名和-JSON-中的-Key-不相同"><a href="#2-Model-属性名和-JSON-中的-Key-不相同" class="headerlink" title="2.Model 属性名和 JSON 中的 Key 不相同"></a>2.Model 属性名和 JSON 中的 Key 不相同</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">// JSON:</div><div class="line">&#123;</div><div class="line">    &quot;n&quot;:&quot;Harry Pottery&quot;,</div><div class="line">    &quot;p&quot;: 256,</div><div class="line">    &quot;ext&quot; : &#123;</div><div class="line">        &quot;desc&quot; : &quot;A book written by J.K.Rowing.&quot;</div><div class="line">    &#125;,</div><div class="line">    &quot;ID&quot; : 100010</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Model:</div><div class="line">@interface Book : NSObject</div><div class="line">@property NSString *name;</div><div class="line">@property NSInteger page;</div><div class="line">@property NSString *desc;</div><div class="line">@property NSString *bookID;</div><div class="line">@end</div><div class="line">@implementation Book</div><div class="line">//返回一个 Dict，将 Model 属性名对映射到 JSON 的 Key。</div><div class="line">+ (NSDictionary *)modelCustomPropertyMapper &#123;</div><div class="line">    return @&#123;@&quot;name&quot; : @&quot;n&quot;,</div><div class="line">             @&quot;page&quot; : @&quot;p&quot;,</div><div class="line">             @&quot;desc&quot; : @&quot;ext.desc&quot;,</div><div class="line">             @&quot;bookID&quot; : @[@&quot;id&quot;,@&quot;ID&quot;,@&quot;book_id&quot;]&#125;;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>你可以把一个或一组 json key (key path) 映射到一个或多个属性。如果一个属性没有映射关系，那默认会使用相同属性名作为映射。<br>在 json-&gt;model 的过程中：如果一个属性对应了多个 json key，那么转换过程会按顺序查找，并使用第一个不为空的值。<br>在 model-&gt;json 的过程中：如果一个属性对应了多个 json key (key path)，那么转换过程仅会处理第一个 json key (key path)；如果多个属性对应了同一个 json key，则转换过过程会使用其中任意一个不为空的值。</p>
<h3 id="3-Model-包含其他-Model"><a href="#3-Model-包含其他-Model" class="headerlink" title="3.Model 包含其他 Model"></a>3.Model 包含其他 Model</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">// JSON</div><div class="line">&#123;</div><div class="line">    &quot;author&quot;:&#123;</div><div class="line">        &quot;name&quot;:&quot;J.K.Rowling&quot;,</div><div class="line">        &quot;birthday&quot;:&quot;1965-07-31T00:00:00+0000&quot;</div><div class="line">    &#125;,</div><div class="line">    &quot;name&quot;:&quot;Harry Potter&quot;,</div><div class="line">    &quot;pages&quot;:256</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Model: 什么都不用做，转换会自动完成</div><div class="line">@interface Author : NSObject</div><div class="line">@property NSString *name;</div><div class="line">@property NSDate *birthday;</div><div class="line">@end</div><div class="line">@implementation Author</div><div class="line">@end</div><div class="line"></div><div class="line">@interface Book : NSObject</div><div class="line">@property NSString *name;</div><div class="line">@property NSUInteger pages;</div><div class="line">@property Author *author; //Book 包含 Author 属性</div><div class="line">@end</div><div class="line">@implementation Book</div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="4-容器类属性"><a href="#4-容器类属性" class="headerlink" title="4.容器类属性"></a>4.容器类属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">@class Shadow, Border, Attachment;</div><div class="line"></div><div class="line">@interface Attributes</div><div class="line">@property NSString *name;</div><div class="line">@property NSArray *shadows; //Array&lt;Shadow&gt;</div><div class="line">@property NSSet *borders; //Set&lt;Border&gt;</div><div class="line">@property NSMutableDictionary *attachments; //Dict&lt;NSString,Attachment&gt;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation Attributes</div><div class="line">// 返回容器类中的所需要存放的数据类型 (以 Class 或 Class Name 的形式)。</div><div class="line">+ (NSDictionary *)modelContainerPropertyGenericClass &#123;</div><div class="line">    return @&#123;@&quot;shadows&quot; : [Shadow class],</div><div class="line">             @&quot;borders&quot; : Border.class,</div><div class="line">             @&quot;attachments&quot; : @&quot;Attachment&quot; &#125;;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>在实际使用过过程中，<code>[Shadow class]</code>，<code>Border.class</code>，<code>@&quot;Attachment&quot;</code>没有明显的区别。<br>这里仅仅是创建作者有说明，实际使用时，需要对其遍历，取出容器中得字典，然后继续字典转模型。（<strong><strong>YYModel</strong></strong>的核心是通过<strong><strong>runtime</strong></strong>获取结构体中得<strong><strong>Ivars</strong></strong>的值，将此值定义为<strong><strong>key,</strong></strong>然后给<strong><strong>key</strong></strong>赋<strong><strong>value</strong></strong>值，所以我们需要自己遍历容器（<strong><strong>NSArray</strong></strong>，<strong><strong>NSSet</strong></strong>，<strong><strong>NSDictionary</strong></strong>），获取每一个值，然后<strong><strong>KVC</strong></strong>）。</p>
<ul>
<li>具体的代码实现如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">NSDictionary *json =[self getJsonWithJsonName:@&quot;ContainerModel&quot;];</div><div class="line">ContainerModel *containModel = [ContainerModel yy_modelWithDictionary:json];</div><div class="line">NSDictionary *dataDict = [containModel valueForKey:@&quot;data&quot;];</div><div class="line">//定义数组，接受key为list的数组</div><div class="line">self.listArray = [dataDict valueForKey:@&quot;list&quot;]; </div><div class="line"> //遍历数组</div><div class="line">[self.listArray enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</div><div class="line">        NSDictionary *listDict = obj;</div><div class="line">        //获取数组中得字典</div><div class="line">        List *listModel = [List yy_modelWithDictionary:listDict];</div><div class="line">        //获取count 和 id</div><div class="line">        NSString *count = [listModel valueForKey:@&quot;count&quot;];</div><div class="line">        NSString *id = [listModel valueForKey:@&quot;id&quot;];</div></pre></td></tr></table></figure>
<h3 id="5-黑名单与白名单"><a href="#5-黑名单与白名单" class="headerlink" title="5.黑名单与白名单"></a>5.黑名单与白名单</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@interface User</div><div class="line">@property NSString *name;</div><div class="line">@property NSUInteger age;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation Attributes</div><div class="line">// 如果实现了该方法，则处理过程中会忽略该列表内的所有属性</div><div class="line">+ (NSArray *)modelPropertyBlacklist &#123;</div><div class="line">    return @[@&quot;test1&quot;, @&quot;test2&quot;];</div><div class="line">&#125;</div><div class="line">// 如果实现了该方法，则处理过程中不会处理该列表外的属性。</div><div class="line">+ (NSArray *)modelPropertyWhitelist &#123;</div><div class="line">    return @[@&quot;name&quot;];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="6-数据校验与自定义转换"><a href="#6-数据校验与自定义转换" class="headerlink" title="6.数据校验与自定义转换"></a>6.数据校验与自定义转换</h3><p>实际这个分类的目的比较简单和明确。<br>就是对判断是否为时间戳，然后对时间戳进行处理，调用<br><code>_createdAt = [NSDate dateWithTimeIntervalSince1970:timestamp.floatValue];</code><br>获取时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">// JSON:</div><div class="line">&#123;</div><div class="line">    &quot;name&quot;:&quot;Harry&quot;,</div><div class="line">    &quot;timestamp&quot; : 1445534567     //时间戳</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Model:</div><div class="line">@interface User</div><div class="line">@property NSString *name;</div><div class="line">@property NSDate *createdAt;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation User</div><div class="line">// 当 JSON 转为 Model 完成后，该方法会被调用。</div><div class="line">// 你可以在这里对数据进行校验，如果校验不通过，可以返回 NO，则该 Model 会被忽略。</div><div class="line">// 你也可以在这里做一些自动转换不能完成的工作。</div><div class="line">- (BOOL)modelCustomTransformFromDictionary:(NSDictionary *)dic &#123;</div><div class="line">    NSNumber *timestamp = dic[@&quot;timestamp&quot;];</div><div class="line">    if (![timestamp isKindOfClass:[NSNumber class]]) return NO;</div><div class="line">    _createdAt = [NSDate dateWithTimeIntervalSince1970:timestamp.floatValue];</div><div class="line">    return YES;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 当 Model 转为 JSON 完成后，该方法会被调用。</div><div class="line">// 你可以在这里对数据进行校验，如果校验不通过，可以返回 NO，则该 Model 会被忽略。</div><div class="line">// 你也可以在这里做一些自动转换不能完成的工作。</div><div class="line">- (BOOL)modelCustomTransformToDictionary:(NSMutableDictionary *)dic &#123;</div><div class="line">    if (!_createdAt) return NO;</div><div class="line">    dic[@&quot;timestamp&quot;] = @(n.timeIntervalSince1970);</div><div class="line">    return YES;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>需要注意的时，如果用插件，对时间戳类型或默认创建为NSUInteger类型，需要将其更改为NSDate类型。</li>
</ul>
</blockquote>
<h3 id="7-Coding-Copying-hash-equal-description"><a href="#7-Coding-Copying-hash-equal-description" class="headerlink" title="7.Coding/Copying/hash/equal/description"></a>7.Coding/Copying/hash/equal/description</h3><p>以下方法都是YYModel的简单封装，实际使用过程和系统方法区别不大。对其感兴趣的可以点进方法内部查看。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">@interface YYShadow :NSObject &lt;NSCoding, NSCopying&gt;</div><div class="line">@property (nonatomic, copy) NSString *name;</div><div class="line">@property (nonatomic, assign) CGSize size;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation YYShadow</div><div class="line">// 直接添加以下代码即可自动完成</div><div class="line">- (void)encodeWithCoder:(NSCoder *)aCoder &#123; </div><div class="line"> [self yy_modelEncodeWithCoder:aCoder]; </div><div class="line">&#125;</div><div class="line">- (id)initWithCoder:(NSCoder *)aDecoder &#123;</div><div class="line">  self = [super init];</div><div class="line">  return [self yy_modelInitWithCoder:aDecoder]; </div><div class="line">&#125;</div><div class="line">- (id)copyWithZone:(NSZone *)zone &#123; </div><div class="line"> return [self yy_modelCopy]; </div><div class="line">&#125;</div><div class="line">- (NSUInteger)hash &#123; </div><div class="line"> return [self yy_modelHash]; </div><div class="line">&#125;</div><div class="line">- (BOOL)isEqual:(id)object &#123; </div><div class="line"> return [self yy_modelIsEqual:object]; </div><div class="line">&#125;</div><div class="line">- (NSString *)description &#123; </div><div class="line"> return [self yy_modelDescription]; </div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>-</p>
<h2 id="二、ESJsonFormat与YYModel的结合使用"><a href="#二、ESJsonFormat与YYModel的结合使用" class="headerlink" title="二、ESJsonFormat与YYModel的结合使用"></a>二、ESJsonFormat与YYModel的结合使用</h2><p><strong>彩蛋</strong><br>给大家介绍一款插件，配合<a href="https://github.com/EnjoySR/ESJsonFormat-Xcode" target="_blank" rel="external">ESJsonFormat</a></p>
<p>配图：<br><img src="http://upload-images.jianshu.io/upload_images/1467716-5c961bc376c72984.gif?imageMogr2/auto-orient/strip" alt="ESJsonFormat插件使用.gif"></p>
<p>使用方法：<br>快捷键：<code>shift + control + J</code><br>插件安装方法比较简单，在此不赘述，不知道可自行google。</p>
<p><strong>好处</strong>：</p>
<blockquote>
<ul>
<li><ol>
<li>可以直接将json数据复制，ESJsonFormat会根据数据类型自动生成属性。（建议还是要自行检查，比如时间戳，系统会默认帮你生成为NSUInteger，而我们想要的为NSDate类型）</li>
</ol>
</li>
<li><ol>
<li>对于多模型嵌套，不必创建多个文件，ESJsonFormat会自动在一个文件下创建多重类型,极其便捷。</li>
</ol>
</li>
</ul>
</blockquote>
<p>至此YYModel的使用已讲解完毕，关于YYModel的底层核心是<code>运用runtime获取类结构体中Ivars，进行KVC操作，然后根据不同情况进行分别处理</code>。<br>此处只是传递给大家一个概念，不展开讲解，网上有很多源码分析文章，可自学google学习。<br>文末，做个综述。<br>建议大家有时间一定要多看底层，分析源码。不要只会用，知其然不知其所以然。<br>如有错误欢迎指出。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://betteris.top/一篇文章全吃透—史上最全YYModel的使用详解/" data-id="ck76887d3000ilvx9izjz150w" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/YYModel/">YYModel</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-KVC和runtime字典转模型对比分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/KVC和runtime字典转模型对比分析/" class="article-date">
  <time datetime="2016-06-18T16:25:33.000Z" itemprop="datePublished">2016-06-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/KVC和runtime字典转模型对比分析/">KVC和runtime字典转模型对比分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文分为两部分：</p>
<p>一：教你怎样一部获取成员属性（通过NSObject+autoLogProperty分类）<br>二：对比KVC和runtime两种字典转模型的方法并抽取一个分类</p>
</blockquote>
<h1 id="一：自定义分类，打印字典转模型的属性声明"><a href="#一：自定义分类，打印字典转模型的属性声明" class="headerlink" title="一：自定义分类，打印字典转模型的属性声明"></a><strong>一：自定义分类，打印字典转模型的属性声明</strong></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">+ (void)createPropertyCodeWithDict:(NSDictionary *)dict</div><div class="line">&#123;</div><div class="line">    NSMutableString *strM = [NSMutableString string];</div><div class="line">    </div><div class="line">    // 遍历字典</div><div class="line">    [dict enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull propertyName, id  _Nonnull value, BOOL * _Nonnull stop) &#123;</div><div class="line">        NSString *code;</div><div class="line">        //__NSCFString  &lt;——&gt;   NSString类型</div><div class="line">        //__NSCFNumber  &lt;——&gt;   int类型</div><div class="line">        //__NSCFArray  &lt;——&gt;    NSArray类型</div><div class="line">        //__NSCFDictionary  &lt;——&gt;   NSDictionary类型</div><div class="line">        //__NSCFBoolean  &lt;——&gt;   BOOL类型</div><div class="line"></div><div class="line">        if ([value isKindOfClass:NSClassFromString(@&quot;__NSCFString&quot;)]) &#123;</div><div class="line">            code = [NSString stringWithFormat:@&quot;@property (nonatomic, strong) NSString *%@;&quot;,propertyName];</div><div class="line">        &#125;else if ([value isKindOfClass:NSClassFromString(@&quot;__NSCFNumber&quot;)])&#123;</div><div class="line">            code = [NSString stringWithFormat:@&quot;@property (nonatomic, assign) int %@;&quot;,propertyName];</div><div class="line">        &#125;else if ([value isKindOfClass:NSClassFromString(@&quot;__NSCFArray&quot;)])&#123;</div><div class="line">            code = [NSString stringWithFormat:@&quot;@property (nonatomic, strong) NSArray *%@;&quot;,propertyName];</div><div class="line">        &#125;else if ([value isKindOfClass:NSClassFromString(@&quot;__NSCFDictionary&quot;)])&#123;</div><div class="line">            code = [NSString stringWithFormat:@&quot;@property (nonatomic, strong) NSDictionary *%@;&quot;,propertyName];</div><div class="line">        &#125;else if ([value isKindOfClass:NSClassFromString(@&quot;__NSCFBoolean&quot;)])&#123;</div><div class="line">            code = [NSString stringWithFormat:@&quot;@property (nonatomic, assign) BOOL %@;&quot;,propertyName];</div><div class="line">        &#125;</div><div class="line">        [strM appendFormat:@&quot;\n%@\n&quot;,code];</div><div class="line">    &#125;];</div><div class="line">    NSLog(@&quot;%@&quot;,strM);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="1-核心思想："><a href="#1-核心思想：" class="headerlink" title="1.核心思想："></a>1.<strong>核心思想：</strong></h2><pre><code>1.遍历自定义类中的成员变量

2.将遍历获取的成员变量定为value,复制给类中的ivar.
</code></pre><h2 id="2-runtime字典转模型与KVC赋值的区别"><a href="#2-runtime字典转模型与KVC赋值的区别" class="headerlink" title="2.runtime字典转模型与KVC赋值的区别:"></a>2.<strong>runtime字典转模型与KVC赋值的区别:</strong></h2><pre><code>KVC是调用`setValue: forKey: `的方法，将系统的成员变量作为value，自定义的属性为key
如果自定义的属性找不到就必须要调用     `- (void)setValue:(id)value forUndefinedKey:(NSString *)key;`
来处理报错。
但是runtime的字典转模型是将自定义属性生成的下划线成员变量变为key.
`setValuesForKeysWithDictionary:`就不会出现找不到key而报错的问题了。
</code></pre><hr>
<h1 id="两种字典转模型的代码："><a href="#两种字典转模型的代码：" class="headerlink" title="两种字典转模型的代码："></a><strong>两种字典转模型的代码：</strong></h1><h2 id="1-KVC方式字典转模型"><a href="#1-KVC方式字典转模型" class="headerlink" title="1.KVC方式字典转模型"></a>1.KVC方式字典转模型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">+ (StatusModel *)statusWithDict:(NSDictionary *)dict</div><div class="line">&#123;</div><div class="line">    StatusModel *statusModel = [[self alloc] init];</div><div class="line">    // KVC</div><div class="line">    [statusModel setValuesForKeysWithDictionary:dict];</div><div class="line">    return statusModel;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 解决KVC报错</div><div class="line">- (void)setValue:(id)value forUndefinedKey:(NSString *)key</div><div class="line">&#123;</div><div class="line">//可以为空，表示不处理，也可以为做一些转换操作</div><div class="line">//    if ([key isEqualToString:@&quot;XXX&quot;]) &#123;</div><div class="line">//        _### = [value integerValue];</div><div class="line">//    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="2-runtime字典转模型"><a href="#2-runtime字典转模型" class="headerlink" title="2.runtime字典转模型"></a>2.runtime字典转模型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)modelWithDict:(NSDictionary *)dict &#123;</div><div class="line">    id objc = [[self alloc] init];</div><div class="line">    unsigned int count = 0;</div><div class="line">    Ivar *ivarList = class_copyIvarList(self, &amp;count);</div><div class="line">    for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">        //获取属性名</div><div class="line">        Ivar ivar = ivarList[i];</div><div class="line">        </div><div class="line">        //获取成员名</div><div class="line">        NSString *propertyName = [NSString stringWithUTF8String:ivar_getName(ivar)];</div><div class="line">        </div><div class="line">        //获取key</div><div class="line">        NSString *key = [propertyName substringFromIndex:1];   //取出下划线_</div><div class="line">        //获取字典中的value</div><div class="line">        id value = dict[key];</div><div class="line">        </div><div class="line">        //获取成员属性类型</div><div class="line">        NSString *propertyType = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)];</div><div class="line"></div><div class="line">        //此处为二级转换，如果里面的为字典类型，且属性类型为二级模型的名字，不为NSDictionary</div><div class="line">        if ([value isKindOfClass:[NSDictionary class]] &amp;&amp; ![propertyType containsString:@&quot;NS&quot;]) &#123; // 需要字典转换成模型</div><div class="line">            // 转换成哪个类型</div><div class="line">            // 打印出来的值为  @&quot;@\&quot;User\&quot;&quot;, 截取成User</div><div class="line">            // 字符串截取</div><div class="line">            NSRange range = [propertyType rangeOfString:@&quot;\&quot;&quot;];</div><div class="line">            propertyType = [propertyType substringFromIndex:range.location + range.length];</div><div class="line">            //此时变为 User\&quot;&quot;;,借着截取掉后面的\&quot;&quot;</div><div class="line">            range = [propertyType rangeOfString:@&quot;\&quot;&quot;];</div><div class="line">            propertyType = [propertyType substringToIndex:range.location];</div><div class="line">            </div><div class="line">            // 获取需要转换类的类对象</div><div class="line">            Class modelClass =  NSClassFromString(propertyType);</div><div class="line">            </div><div class="line">            if (modelClass) &#123;</div><div class="line">                value =  [modelClass modelWithDict:value];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (value) &#123;</div><div class="line">            // KVC赋值:不能传空</div><div class="line">            [objc setValue:value forKey:key];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return objc;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-具体使用"><a href="#3-具体使用" class="headerlink" title="3.具体使用"></a>3.<strong>具体使用</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;status.plist&quot; ofType:nil];</div><div class="line">    NSDictionary *dict = [NSDictionary dictionaryWithContentsOfFile:filePath];</div><div class="line">    </div><div class="line">    //log方法属性</div><div class="line">    NSArray *dictArr = dict[@&quot;statuses&quot;];</div><div class="line">    [[self class] createPropertyCodeWithDict:dictArr[0]];            //打印StatusModel的属性</div><div class="line">    [[self class] createPropertyCodeWithDict:dictArr[0][@&quot;user&quot;]];   //打印UserModel的属性</div><div class="line">    </div><div class="line">    NSMutableArray *statuses = [NSMutableArray array];</div><div class="line">    // 遍历字典数组</div><div class="line">    for (NSDictionary *dict in dictArr) &#123;</div><div class="line">//        KVC字典转模型，调用setValueForKeyWithDictionary:方法</div><div class="line">//        StatusModel *statusModel = [StatusModel statusWithDict:dict];</div><div class="line">        </div><div class="line">//       runtime字典转模型，调用分类方法</div><div class="line">        StatusModel *statusModel = [StatusModel modelWithDict:dict];</div><div class="line">        [statuses addObject:statusModel];</div><div class="line">    &#125;</div><div class="line">    NSLog(@&quot;%@&quot;,statuses);</div><div class="line">    self.dataArray = statuses;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//懒加载dataArray</div><div class="line">- (NSMutableArray *)dataArray</div><div class="line">&#123;</div><div class="line">    if (!_dataArray) &#123;</div><div class="line">        _dataArray  = [NSMutableArray array];</div><div class="line">    &#125;</div><div class="line">    return _dataArray;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/walkertop/Runtime-" target="_blank" rel="external">点击下载demo</a></p>
<p>注意：demo中的工具类可以抽取使用</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://betteris.top/KVC和runtime字典转模型对比分析/" data-id="ck76887cp0002lvx9kycu4hxc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/KVC-Runtime/">KVC Runtime</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-runloop" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/runloop/" class="article-date">
  <time datetime="2016-06-08T10:37:28.000Z" itemprop="datePublished">2016-06-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/runloop/">对，我就是RunLoop</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#以下是RunLoop和iOS搬砖程序员的访谈#</div></pre></td></tr></table></figure>
<blockquote>
<p>“请问你是？”</p>
</blockquote>
<p> “不用请问，我就是RunLoop”</p>
<blockquote>
<p>“你好，我是iOS开发者，我听说过你，不过抱歉，对你的名声我早有耳闻，只是不很熟悉。”</p>
</blockquote>
<p> ”嗯，不难理解。毕竟我在幕后，你在台前，我是说句不妄言的话，没有我，你们就别想玩的转。“</p>
<blockquote>
<p>”哦 ？ 这么说的话，我确实很好奇，请问你能不能介绍下你自己！</p>
</blockquote>
<h2 id="RunLoop的概念"><a href="#RunLoop的概念" class="headerlink" title="RunLoop的概念"></a>RunLoop的概念</h2><p>人如其名，我就是RunLoooooooooooooooop,像是一个死循环，不停的跑圈，永不懈怠。除非程序不启动，或者你们代码写的太差，以至于crash,我才不得不停止了。</p>
<blockquote>
<p>可是程序启动与否和你有什么关系？</p>
</blockquote>
<p> 程序启动伊始，有一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">     @autoreleasepool &#123;</div><div class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([YourAppDelegate class]));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码永远不会执行结束，不然程序也停止了。所以我伴随着程序的启动，一直存在。<br>当然，我不可能无意义的瞎跑。我贯穿整个程序，在奔跑的过程中帮忙处理各种事情。</p>
<hr>
<blockquote>
<p>我主观上听明白了你的意思，但冒昧的说一句，除了瞎跑我还真不知道你到底做了啥？</p>
</blockquote>
<p>我理解，我理解，毕竟你们花费大量的时间和UIKit和Foundation的各种类打交道，丝毫不顾及我的存在感。但你有没有好奇过，你的事件响应，各种手势识别，定时器都是怎么传递的啊？</p>
<blockquote>
<p>抱歉，你这么一问，我确实欠考虑了。</p>
</blockquote>
<p>对啊，所以这就是我从幕后走向台前的目的。写代码不能只看表面，还要挖挖本质。话说回来，官方点说呢，我就是消息机制的处理模式，从线程start到线程end，一直在循环检测，检测inputSource(如点击，双击等操作)同步事件，检测timeSource同步事件，检测到输入源后会执行处理函数，首先会产生通知，CoreFunction向线程添加runLoop Observers来监听事件，意在监听事件发生时来做处理。</p>
<h2 id="RunLoop和线程之间的关系"><a href="#RunLoop和线程之间的关系" class="headerlink" title="RunLoop和线程之间的关系"></a>RunLoop和线程之间的关系</h2><blockquote>
<p>麻烦停一下，我只知道很多事情是线程来做的，比如页面刷新交给主线程，异步线程来下载。但听你的口气，这些功劳都是你的了？</p>
</blockquote>
<p>对，从表面看来你们都是在操作线程，但这只是表面。我和线程是绑定在一起的。每个线程都有一个对应的 Runloop 对象。当然不同线程的RunLoop是有区别的，主线程（也是你们常说的UI线程）的 Runloop 会在应用启动时完成启动，其他线程的 Runloop 默认并不会启动，只是在需要使用时，你们手动启动。</p>
<h2 id="RunLoop不同的Mode"><a href="#RunLoop不同的Mode" class="headerlink" title="RunLoop不同的Mode"></a>RunLoop不同的Mode</h2><blockquote>
<p>你的意思是，每一个线程都有一个RunLoop，但默认情况下只有主线程的才会开启。</p>
</blockquote>
<p>对，不仅每个线程都有RunLoop，而且每一个 RunLoop都包含若干个 Mode，这么给你解释吧，你肯定玩过LOL吧，知道里面有<code>鞋子</code>的装备吧。</p>
<blockquote>
<p>这个倒忘不掉。</p>
</blockquote>
<p>那就好说了，正常来说，每个鞋子都有自己偏重的功能属性，不同英雄都只会买一种鞋子对不对。我也一样，我虽然有多个Mode，但就像穿鞋一样，每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 RunLoop，再重新指定一个 Mode 进入。这就像换鞋子一样，必须先脱掉旧鞋才能穿上新鞋。</p>
<blockquote>
<p>当然，鞋子不同，有的偏重法术，有的偏重攻速，你所谓的Mode是怎么区分不同的？</p>
</blockquote>
<p> 其实每个 Mode 包含若干个 <code>Source</code>/<code>Timer</code>/<code>Observer</code>，这些都属于Mode的item，item不同，Mode也不同，RunLoop分为五类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSDefaultRunLoopMode    //大多数工作中默认的运行方式</div><div class="line">NSConnectionReplyMode    //使用这个Mode去监听NSConnection对象的状态，我们很少需要自己使用这个Mode</div><div class="line">NSModalPanelRunLoopMode    //在Model Panel情况下去区分事件(OS X开发中会遇到)</div><div class="line">NSEventTrackingRunLoopMode    //跟踪来自用户交互的事件（比如UITableView上下滑动）</div><div class="line">NSRunLoopCommonModes    //这是一个伪模式，其为一组run loop mode的集合</div></pre></td></tr></table></figure>
<p>虽然模式很多，但iOS中公开暴露出来的只有 NSDefaultRunLoopMode 和 NSRunLoopCommonModes。 NSRunLoopCommonModes 实际上是一个 Mode 的集合，默认包括 NSDefaultRunLoopMode 和 NSEventTrackingRunLoopMode。</p>
<blockquote>
<p>这里就有点抽象了，这么多Mode你是怎么选择的呢？</p>
</blockquote>
<p>主线程的 RunLoop 里有两个预置的 Mode：NSDefaultRunLoopMode和 NSEventTrackingRunLoopMode。这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。</p>
<blockquote>
<p>但如果我想滑动ScrollView时，不影响Timer咋办？</p>
</blockquote>
<p> 既然在DefaultMode下，不影响Timer，TrackingRunLoopMode下能滑动，两者都不影响，就是两种模式都要就ok了，iOS中的commonModeItems就是就是将DefaultMode和TrackingRunLoopMode组合在一起了，因此只用切换到commonModeItems就ok了。</p>
<hr>
<h2 id="RunLoop的内部逻辑"><a href="#RunLoop的内部逻辑" class="headerlink" title="RunLoop的内部逻辑"></a>RunLoop的内部逻辑</h2><blockquote>
<p>哈哈，果真我对你了解的太不到位了，原来你是超神的存在。</p>
</blockquote>
<p>不不不，超神不至于，其实我也只是给系统跑腿罢了。但我的一举一动也要接受管理，不能随便乱来。</p>
<blockquote>
<p>谁还能管的了你啊？</p>
</blockquote>
<p>怎么管不了，能力大，责任大。我要时时刻刻接受系统的监督。你们对我的了解可能从NSRunLoop开始的，但这实际只是OC对我简单的封装，我的底层是C语言库CFRunLoop，这里面有一个叫CFRunLoopObserverRef的观察者，也就是前面我给你提到的<code>Observer</code>，当我的状态发生改变时，观察者就会记录我的变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</div><div class="line">    kCFRunLoopEntry         = (1UL &lt;&lt; 0), // 即将进入Loop</div><div class="line">    kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1), // 即将处理 Timer</div><div class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source</div><div class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠</div><div class="line">    kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6), // 刚从休眠中唤醒</div><div class="line">    kCFRunLoopExit          = (1UL &lt;&lt; 7), // 即将退出Loop</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<blockquote>
<p>这个倒不难理解，毕竟UIView，UIController，UIApplication都有类似的管理。</p>
</blockquote>
<h2 id="RunLoop与NSTimer的准时触发"><a href="#RunLoop与NSTimer的准时触发" class="headerlink" title="RunLoop与NSTimer的准时触发"></a>RunLoop与NSTimer的准时触发</h2><blockquote>
<p>可是RunLoop与NSTimer有什么关系呢？</p>
</blockquote>
<p>NSTimer其实是一种资源，但它要想起作用必须添加到RunLoop中。</p>
<blockquote>
<p>NSTimer会是准时触发事件吗？</p>
</blockquote>
<p>timer不是一种实时的机制，会存在延迟，而且延迟的程度跟当前线程的执行情况有关。</p>
<blockquote>
<p>这个怎么理解？</p>
</blockquote>
<p>正常情况下，你指定一个事件2秒之后触发，但若是此时恰好有一个大规模的连续耗时运算，那timer的执行必然要等到该连续事件处理结束才会开始执行，此时你就无法保证NSTimer的准时触发了。当然这只是针对于一次执行的timer，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[NSTimer scheduledTimerWithTimeInterval:1 target:testObject2 selector:@selector(timerAction:) userInfo:nil repeats:YES];</div></pre></td></tr></table></figure></p>
<p>对于重复性事件，情况也不一样。比如一个程序，你设置了周期性1秒触发，但是有个耗时事件用时两秒，此时就无法准确触发，并且以后会随着这个延迟继续延迟。</p>
<h2 id="RunLoop的相关实战"><a href="#RunLoop的相关实战" class="headerlink" title="RunLoop的相关实战"></a>RunLoop的相关实战</h2><blockquote>
<p>说了那么多，我大约感受到你的神奇魔力了，但还是过于抽象和偏理论，有没有具体的实例来彰显你的存在感啊！</p>
</blockquote>
<p>那是必然，那我虎躯一震，抖一抖我的黑魔法。给你说几个具体的场景吧。</p>
<h3 id="AutoreleasePool的真谛"><a href="#AutoreleasePool的真谛" class="headerlink" title="AutoreleasePool的真谛"></a>AutoreleasePool的真谛</h3><p>问你个问题：从MRC的手动管理内存，到ARC的自动管理，其关键因素是什么？</p>
<blockquote>
<p>因为多了AutoreleasePool，自动释放池。只是我也不知道AutoreleasePool背后到底帮助我们做了什么？</p>
</blockquote>
<p>哈哈，其实这和我RunLoop有很大的关系，在App启动后，会在主线程度的RunLoop帮我们创建两个Observer。<br>第一个 Observer 只监视了一个事件：监听事件在Entry(即将进入Loop)期间，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。<br>第二个 Observer 监视了两个事件：在BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的，被这些inputSource和timeSource包裹。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p>
<blockquote>
<p>你这么一说我就理解了，难怪之前有人告诉我，内存的释放是在每次RunLoop结束之后呢。</p>
</blockquote>
<p>这算是一个场景，当然还有其它的。</p>
<h3 id="关于performSelecter-afterDelay-方法"><a href="#关于performSelecter-afterDelay-方法" class="headerlink" title="关于performSelecter:afterDelay:方法"></a>关于<code>performSelecter:afterDelay:</code>方法</h3><blockquote>
<p>好的，你接着说。</p>
</blockquote>
<p> 你有没有遇到过这样的场景，我在子线程中执行<code>performSelecter:</code>，一切ok，但加了延时，执行<code>performSelecter:afterDelay:</code>方法时，却愣是没反应？</p>
<blockquote>
<p>对对对，后来别人告诉我在子线程开了RunLoop就ok了，至于为何，我现在还是云里雾里的。</p>
</blockquote>
<p>其实这和NSTimer有关，当调用 NSObject 的 <code>performSelecter:afterDelay:</code> 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。而子线程默认没有开启RunLoop，就无法执行timer事件，自然就不执行。</p>
<blockquote>
<p>原来如此。</p>
</blockquote>
<h3 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h3><blockquote>
<p>既然聊到了线程问题，我想问下线程之间的通信问题。比如我在异步子线程执行了网络请求，想把请求回来的结果通过异步主线程<code>dispatch_async(dispatch_get_main_queue(), block)</code>，的方式将block回调给主线程，这应该也很你们有关系吧。</p>
</blockquote>
<p>对的，对于子线程和主线程之间的通信。当调用 <code>dispatch_async(dispatch_get_main_queue()</code>, block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 <strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong>() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://betteris.top/runloop/" data-id="ck76887cw0008lvx9z1dk9wgt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS-RunLoop/">iOS RunLoop</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-看不会这篇就没脸说懂setter-getter" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/看不会这篇就没脸说懂setter-getter/" class="article-date">
  <time datetime="2016-05-19T07:37:38.000Z" itemprop="datePublished">2016-05-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/看不会这篇就没脸说懂setter-getter/">看不会这篇就没脸说懂setter/getter</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><code>setter/getter</code>是一个类最基本的东西，任何一门面向对象的语言，都有这个概念，C++、java等等。因为<code>setter/getter</code>是对面向对象语言封装的最基本的支持。</p>
<h2 id="OC中的setter-getter特点和变化"><a href="#OC中的setter-getter特点和变化" class="headerlink" title="OC中的setter/getter特点和变化"></a>OC中的setter/getter特点和变化</h2><p>OC的<code>setter/getter</code>和其他面向对象的语言没有什么不同。只不过，添加了一些自己的特性。</p>
<h2 id="LLVM编译器下的setter-getter的实质。"><a href="#LLVM编译器下的setter-getter的实质。" class="headerlink" title="LLVM编译器下的setter/getter的实质。"></a>LLVM编译器下的<code>setter/getter</code>的实质。</h2><p>我们都知道<code>@property</code>实质帮我们做了<code>setter</code>、<code>getter</code>和生成<code>_属性名</code>的三部操作，具体情况是怎样的呢，下面三部将给你一一揭示<code>@peroperty</code>的实质。</p>
<h3 id="Step1-成员变量"><a href="#Step1-成员变量" class="headerlink" title="Step1:成员变量"></a><code>Step1:</code>成员变量</h3><p>首先查找是否有以<code>_属性名</code>命名的成员变量。</p>
<p>如果有，默认对其进行set和get；</p>
<p>如果没有，则隐式生成以<code>_属性名</code>命名的成员变量；</p>
<p>实际LLVM编译器会隐形的帮我们创建一个<code>_属性名</code>的成员变量。</p>
<p>&lt;不过注意，编译器会先检测有无相关成员变量，有不创建，无才创建，下文会有详细说明&gt;</p>
<h3 id="Step2-系统默认实现setter方法"><a href="#Step2-系统默认实现setter方法" class="headerlink" title="Step2:系统默认实现setter方法"></a><code>Step2:</code>系统默认实现<code>setter</code>方法</h3><p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (void)setName:(NSString *)name &#123;</div><div class="line">    _name = name;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Step3-系统默认实现getter方法"><a href="#Step3-系统默认实现getter方法" class="headerlink" title="Step3:系统默认实现getter方法"></a><code>Step3:</code>系统默认实现<code>getter</code>方法</h3><p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (NSString *)name &#123;</div><div class="line">    return _name;   //调用getter方法返回的是下划线的成员变量。</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="更改-property的-属性"><a href="#更改-property的-属性" class="headerlink" title="更改@property的_属性"></a>更改@property的<code>_属性</code></h2><p>虽然系统默认帮助我们生成了<em>属性名的成员变量，假如我们并不想如此，而是把系统的</em>属性更改为制定的成员变量。接下来怎操作呢？<br>实质上是由两种方法的，下面一一介绍:</p>
<h3 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h3><p>重写<code>setter/getter</code>方法，将<code>_属性名</code> 更改为我们想要的名字；</p>
<h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二:"></a>方式二:</h3><p>直接使用<code>@synthesize 属性名 = 指定属性名</code>；<br>两种创建方式的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">@interface ViewController () &#123;</div><div class="line">    </div><div class="line">    NSString *mySynthesizeString2;   //synthesize方法</div><div class="line">    NSString *setterString;          //setter的string</div><div class="line">&#125;</div><div class="line">@property(nonatomic,copy) NSString *myString1;</div><div class="line"></div><div class="line">@property(nonatomic,copy) NSString *myString2;  //@synthesize</div><div class="line"></div><div class="line">@property(nonatomic,copy) NSString *myString3;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">@synthesize myString1;          //没有_myString1</div><div class="line"></div><div class="line">@synthesize myString2 = mySynthesizeString2;    //将成员变量变为mySynthesizeString2</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];   </div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> *  通过重写setter方法改变成员变量的值</div><div class="line"> *</div><div class="line"> *  @param myString2 将自定义的成员变量setterString赋值给myString2，</div><div class="line"> *  以后调setter实际获得的是setterString，  _myString2 已不存在</div><div class="line"> */</div><div class="line">- (void)setMyString2:(NSString *)myString2 &#123;</div><div class="line">    setterString = myString1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSString *)myString2 &#123;</div><div class="line">    return setterString;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="关于-property的属性注意事项"><a href="#关于-property的属性注意事项" class="headerlink" title="关于@property的属性注意事项"></a>关于<code>@property</code>的属性注意事项</h2><blockquote>
<p>使用属性注意事项：</p>
<p>1、当属性名与成员变量名一样时，如果我们想保证成员变量有值，那么就需要在<code>.m</code>中加入<code>@synthesize</code> 变量名；</p>
<p>2、当属性名与成员变量名一样时，如果我们对成员变量的值不强求，但我们又想打印所赋的值，这时在<code>.m</code>里可以使用(<code>_属性名</code>) 或者<code>self.属性名</code>；</p>
<p>3、当定义一个属性时，会首先查找是否有以 <em>属性名 命名的成员变量，如果有，默认对其进行<code>setter/getter</code>，如果没有，则隐式生成以`</em>属性名`命名的成员变量；</p>
<p>4、当我们使用属性时成员变量可以省略。<br>(当<code>.h</code>文件中的成员变量名不省略时 <code>.m</code>文件中的<code>@synthesize</code> 也不能省略！当成员变量名省略时<code>@synthesize</code>也可以省略）</p>
</blockquote>
<h2 id="扩展关于setter-getter-readonly-readwrite"><a href="#扩展关于setter-getter-readonly-readwrite" class="headerlink" title="扩展关于setter,getter,readonly,readwrite"></a>扩展关于setter,getter,readonly,readwrite</h2><h3 id="（1）设置访问方法的名字"><a href="#（1）设置访问方法的名字" class="headerlink" title="（1）设置访问方法的名字"></a>（1）设置访问方法的名字</h3><p>默认的getter和setter器的名称是和变量名关联的，一定是setVirableName和virableName，比如上面的变量age，setter是setAge，getter是age。<br>可以通过设置@property中的setter和getter属性来修改setter和getter器的方法名。<br><code>getter=getterName</code><br><code>setter=setterName</code></p>
<p>举个例子：<code>@property (getter=show1,setter=show2:)int age;</code>//现在，它的getter和setter的方法名字就变了<br>注意：如果你设置了readonly属性的话，那么你就不应该设置setter属性，要不然会给出一个编译器的警告。</p>
<h3 id="（2）设置只读或读写"><a href="#（2）设置只读或读写" class="headerlink" title="（2）设置只读或读写"></a>（2）设置只读或读写</h3><p>下面两个属性很好理解，<br><code>readwrite</code>：表示既有getter，也有setter<br><code>readonly</code>：表示只有getter，没有setter<br>这两个属性是互相排斥的，只能存在一个。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://betteris.top/看不会这篇就没脸说懂setter-getter/" data-id="ck76887d8000tlvx93xm0vzb0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/setter-getter/">setter/getter</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-三分钟教会你runtime获取属性和成员变量" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/三分钟教会你runtime获取属性和成员变量/" class="article-date">
  <time datetime="2016-05-09T02:10:59.000Z" itemprop="datePublished">2016-05-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/三分钟教会你runtime获取属性和成员变量/">三分钟教会你runtime获取属性和成员变量</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><blockquote>
<ul>
<li>成员变量和属性到底是什么？</li>
<li>怎么通过runtime获取属性？</li>
<li>怎么通过runtime获取成员变量？ </li>
<li>成员变量和属性的区别？</li>
<li>实际应用场景是什么？</li>
</ul>
</blockquote>
<h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><h3 id="1、成员变量的定义"><a href="#1、成员变量的定义" class="headerlink" title="1、成员变量的定义"></a>1、成员变量的定义</h3><blockquote>
<p>Ivar: 实例变量类型，是一个指向<code>objc_ivar</code>结构体的指针<br><code>typedef struct objc_ivar *Ivar;</code></p>
</blockquote>
<h3 id="2、相关函数"><a href="#2、相关函数" class="headerlink" title="2、相关函数"></a>2、相关函数</h3><blockquote>
<p>// 获取所有成员变量<br><code>class_copyIvarList</code><br>// 获取成员变量名<br><code>ivar_getName</code><br>// 获取成员变量类型编码<br><code>ivar_getTypeEncoding</code><br>// 获取指定名称的成员变量<br><code>class_getInstanceVariable</code><br>// 获取某个对象成员变量的值<br><code>object_getIvar</code><br>// 设置某个对象成员变量的值<br><code>object_setIvar</code></p>
</blockquote>
<p><strong>说明：</strong><br><code>property_getAttributes</code>函数返回<code>objc_property_attribute_t</code>结构体列表，<code>objc_property_attribute_t</code>结构体包含<code>name</code>和<code>value</code>，常用的属性如下：</p>
<p>属性类型  <code>name</code>值：T                                     <code>value：</code>变化<br>编码类型  <code>name</code>值：C(copy) &amp;(strong) W(weak)空(assign) 等 <code>value：</code>无<br>非/原子性 <code>name</code>值：空(atomic) N(Nonatomic)                <code>value：</code>无<br>变量名称  <code>name</code>值：V                                        <code>value：</code>变化</p>
<p>使用<code>property_getAttributes</code>获得的描述是<code>property_copyAttributeList</code>能获取到的所有的<code>name</code>和<code>value</code>的总体描述，如 T@”NSDictionary”,C,N,V_dict1</p>
<h3 id="3、实例应用"><a href="#3、实例应用" class="headerlink" title="3、实例应用"></a>3、实例应用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;!--Person.h文件--&gt;</div><div class="line">@interface Person : NSObject</div><div class="line">&#123;</div><div class="line">    NSString *address;</div><div class="line">&#125;</div><div class="line">@property(nonatomic,strong)NSString *name;</div><div class="line">@property(nonatomic,assign)NSInteger age;</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//遍历获取Person类所有的成员变量IvarList</div><div class="line">- (void) getAllIvarList &#123;</div><div class="line">    unsigned int methodCount = 0;</div><div class="line">    Ivar * ivars = class_copyIvarList([Person class], &amp;methodCount);</div><div class="line">    for (unsigned int i = 0; i &lt; methodCount; i ++) &#123;</div><div class="line">        Ivar ivar = ivars[i];</div><div class="line">        const char * name = ivar_getName(ivar);</div><div class="line">        const char * type = ivar_getTypeEncoding(ivar);</div><div class="line">        NSLog(@&quot;Person拥有的成员变量的类型为%s，名字为 %s &quot;,type, name);</div><div class="line">    &#125;</div><div class="line">    free(ivars);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;!--打印结果--&gt;</div><div class="line">2016-06-15 20:26:39.412 demo-Cocoa之method swizzle[17798:2565569] Person拥有的成员变量的类型为@&quot;NSString&quot;，名字为 address </div><div class="line">2016-06-15 20:26:39.413 demo-Cocoa之method swizzle[17798:2565569] Person拥有的成员变量的类型为@&quot;NSString&quot;，名字为 _name </div><div class="line">2016-06-15 20:26:39.413 demo-Cocoa之method swizzle[17798:2565569] Person拥有的成员变量的类型为q，名字为 _age</div></pre></td></tr></table></figure>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="1、属性的定义"><a href="#1、属性的定义" class="headerlink" title="1、属性的定义"></a>1、属性的定义</h3><blockquote>
<p><code>objc_property_t</code>：声明的属性的类型，是一个指向<code>objc_property</code>结构体的指针<br><code>typedef struct objc_property *objc_property_t;</code></p>
</blockquote>
<h3 id="2、相关函数-1"><a href="#2、相关函数-1" class="headerlink" title="2、相关函数"></a>2、相关函数</h3><blockquote>
<p>// 获取所有属性<br><code>class_copyPropertyList</code><br>说明：使用<code>class_copyPropertyList</code>并不会获取无<code>@property</code>声明的成员变量<br>// 获取属性名<br><code>property_getName</code><br>// 获取属性特性描述字符串<br><code>property_getAttributes</code><br>// 获取所有属性特性<br><code>property_copyAttributeList</code> </p>
</blockquote>
<h3 id="3、实例应用-1"><a href="#3、实例应用-1" class="headerlink" title="3、实例应用"></a>3、实例应用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;!--Person.h文件--&gt;</div><div class="line">@interface Person : NSObject</div><div class="line">&#123;</div><div class="line">    NSString *address;</div><div class="line">&#125;</div><div class="line">@property(nonatomic,strong)NSString *name;</div><div class="line">@property(nonatomic,assign)NSInteger age;</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//遍历获取所有属性Property</div><div class="line">- (void) getAllProperty &#123;</div><div class="line">    unsigned int propertyCount = 0;</div><div class="line">    objc_property_t *propertyList = class_copyPropertyList([Person class], &amp;propertyCount);</div><div class="line">    for (unsigned int i = 0; i &lt; propertyCount; i++ ) &#123;</div><div class="line">        objc_property_t *thisProperty = propertyList[i];</div><div class="line">        const char* propertyName = property_getName(*thisProperty);</div><div class="line">        NSLog(@&quot;Person拥有的属性为: &apos;%s&apos;&quot;, propertyName);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;!--打印结果--&gt;</div><div class="line">2016-06-15 20:25:19.653 demo-Cocoa之method swizzle[17778:2564081] Person拥有的属性为: &apos;name&apos;</div><div class="line">2016-06-15 20:25:19.653 demo-Cocoa之method swizzle[17778:2564081] Person拥有的属性为: &apos;age&apos;</div></pre></td></tr></table></figure>
<h2 id="应用具体场景"><a href="#应用具体场景" class="headerlink" title="应用具体场景"></a>应用具体场景</h2><h3 id="1、Json到Model的转化"><a href="#1、Json到Model的转化" class="headerlink" title="1、Json到Model的转化"></a>1、Json到Model的转化</h3><p>在开发中相信最常用的就是接口数据需要转化成Model了（当然如果你是直接从Dict取值的话。。。），很多开发者也都使用著名的第三方库如<code>JsonModel</code>、<code>Mantle</code>或<code>MJExtension</code>等，如果只用而不知其所以然，那真和“搬砖”没啥区别了，下面我们使用runtime去解析json来给Model赋值。</p>
<p>原理描述：用runtime提供的函数遍历Model自身所有属性，如果属性在json中有对应的值，则将其赋值。</p>
<p>核心方法：在NSObject的分类中添加方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">- (instancetype)initWithDict:(NSDictionary *)dict &#123;</div><div class="line"> </div><div class="line">    if (self = [self init]) &#123;</div><div class="line">        //(1)获取类的属性及属性对应的类型</div><div class="line">        NSMutableArray * keys = [NSMutableArray array];</div><div class="line">        NSMutableArray * attributes = [NSMutableArray array];</div><div class="line">        /*</div><div class="line">         * 例子</div><div class="line">         * name = value3 attribute = T@&quot;NSString&quot;,C,N,V_value3</div><div class="line">         * name = value4 attribute = T^i,N,V_value4</div><div class="line">         */</div><div class="line">        unsigned int outCount;</div><div class="line">        objc_property_t * properties = class_copyPropertyList([self class], &amp;outCount);</div><div class="line">        for (int i = 0; i &lt; outCount; i ++) &#123;</div><div class="line">            objc_property_t property = properties[i];</div><div class="line">            //通过property_getName函数获得属性的名字</div><div class="line">            NSString * propertyName = [NSString stringWithCString:property_getName(property) encoding:NSUTF8StringEncoding];</div><div class="line">            [keys addObject:propertyName];</div><div class="line">            //通过property_getAttributes函数可以获得属性的名字和@encode编码</div><div class="line">            NSString * propertyAttribute = [NSString stringWithCString:property_getAttributes(property) encoding:NSUTF8StringEncoding];</div><div class="line">            [attributes addObject:propertyAttribute];</div><div class="line">        &#125;</div><div class="line">        //立即释放properties指向的内存</div><div class="line">        free(properties);</div><div class="line"> </div><div class="line">        //(2)根据类型给属性赋值</div><div class="line">        for (NSString * key in keys) &#123;</div><div class="line">            if ([dict valueForKey:key] == nil) continue;</div><div class="line">            [self setValue:[dict valueForKey:key] forKey:key];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>读者可以进一步思考：</p>
<p>如何识别基本数据类型的属性并处理<br>空（nil，null）值的处理<br>json中嵌套json（Dict或Array）的处理</p>
<p>尝试解决以上问题，你也能写出属于自己的功能完备的Json转Model库。</p>
<h3 id="2、快速归档"><a href="#2、快速归档" class="headerlink" title="2、快速归档"></a>2、快速归档</h3><p>有时候我们要对一些信息进行归档，如用户信息类UserInfo，这将需要重写<code>initWithCoder</code>和<code>encodeWithCoder</code>方法，并对每个属性进行<code>encode</code>和<code>decode</code>操作。那么问题来了：当属性只有几个的时候可以轻松写完，如果有几十个属性呢？那不得写到天荒地老.</p>
<p>原理描述：用runtime提供的函数遍历Model自身所有属性，并对属性进行<code>encode</code>和<code>decode</code>操作。</p>
<p>核心方法：在Model的基类中重写方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (id)initWithCoder:(NSCoder *)aDecoder &#123;</div><div class="line">    if (self = [super init]) &#123;</div><div class="line">        unsigned int outCount;</div><div class="line">        Ivar * ivars = class_copyIvarList([self class], &amp;outCount);</div><div class="line">        for (int i = 0; i &lt; outCount; i ++) &#123;</div><div class="line">            Ivar ivar = ivars[i];</div><div class="line">            NSString * key = [NSString stringWithUTF8String:ivar_getName(ivar)];</div><div class="line">            [self setValue:[aDecoder decodeObjectForKey:key] forKey:key];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)encodeWithCoder:(NSCoder *)aCoder &#123;</div><div class="line">    unsigned int outCount;</div><div class="line">    Ivar * ivars = class_copyIvarList([self class], &amp;outCount);</div><div class="line">    for (int i = 0; i &lt; outCount; i ++) &#123;</div><div class="line">        Ivar ivar = ivars[i];</div><div class="line">        NSString * key = [NSString stringWithUTF8String:ivar_getName(ivar)];</div><div class="line">        [aCoder encodeObject:[self valueForKey:key] forKey:key];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3、访问私有变量"><a href="#3、访问私有变量" class="headerlink" title="3、访问私有变量"></a>3、访问私有变量</h3><p>我们知道，OC中没有真正意义上的私有变量和方法，要让成员变量私有，要放在m文件中声明，不对外暴露。如果我们知道这个成员变量的名称，可以通过runtime获取成员变量，再通过<code>getIvar</code>来获取它的值。</p>
<p>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Ivar ivar = class_getInstanceVariable([Model class], &quot;_str1&quot;);</div><div class="line">NSString * str1 = object_getIvar(model, ivar);</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://betteris.top/三分钟教会你runtime获取属性和成员变量/" data-id="ck76887d2000glvx92c80vx4q" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/runtime/">runtime</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/KVC-Runtime/">KVC Runtime</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RAC/">RAC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RAC-MVVM/">RAC MVVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/YYModel/">YYModel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/category/">category</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS-RunLoop/">iOS RunLoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/runtime/">runtime</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/runtime-KVO/">runtime, KVO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/setter-getter/">setter/getter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/swift/">swift</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/成员变量-属性/">成员变量 属性</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/读书笔记/">读书笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/KVC-Runtime/" style="font-size: 10px;">KVC Runtime</a> <a href="/tags/RAC/" style="font-size: 20px;">RAC</a> <a href="/tags/RAC-MVVM/" style="font-size: 10px;">RAC MVVM</a> <a href="/tags/YYModel/" style="font-size: 10px;">YYModel</a> <a href="/tags/category/" style="font-size: 10px;">category</a> <a href="/tags/iOS-RunLoop/" style="font-size: 10px;">iOS RunLoop</a> <a href="/tags/runtime/" style="font-size: 20px;">runtime</a> <a href="/tags/runtime-KVO/" style="font-size: 10px;">runtime, KVO</a> <a href="/tags/setter-getter/" style="font-size: 10px;">setter/getter</a> <a href="/tags/swift/" style="font-size: 10px;">swift</a> <a href="/tags/成员变量-属性/" style="font-size: 10px;">成员变量 属性</a> <a href="/tags/读书笔记/" style="font-size: 10px;">读书笔记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/swift的数据类型到底是什么尿性-说点别人没讲明白的）/">swift的数据类型到底是什么尿性 (说点别人没讲明白的）</a>
          </li>
        
          <li>
            <a href="/0821杂谈/">0821杂谈</a>
          </li>
        
          <li>
            <a href="/紧张兮兮的一个月/">紧张兮兮的一个月</a>
          </li>
        
          <li>
            <a href="/《把时间当作朋友》读书笔记/">《把时间当作朋友》读书笔记</a>
          </li>
        
          <li>
            <a href="/解释automaticallyAdjustsScrollViewInsets，extendedLayoutIncludesOpaqueBars，edgesForExtendedLayout的不同/">解释automaticallyAdjustsScrollViewInsets，extendedLayoutIncludesOpaqueBars，edgesForExtendedLayout的不同</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Walker Guo<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>